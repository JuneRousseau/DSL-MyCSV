/*
 * generated by Xtext 2.23.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.myCsv.AdditiveExpression;
import org.xtext.myCsv.AdditiveExpressionRhs;
import org.xtext.myCsv.AggregatExpression;
import org.xtext.myCsv.AndExpression;
import org.xtext.myCsv.CellIndex;
import org.xtext.myCsv.DeleteField;
import org.xtext.myCsv.DeleteLine;
import org.xtext.myCsv.ExportJson;
import org.xtext.myCsv.ExpressionCalcul;
import org.xtext.myCsv.ExpressionLog;
import org.xtext.myCsv.ExpressionRel;
import org.xtext.myCsv.Field;
import org.xtext.myCsv.FieldIndexName;
import org.xtext.myCsv.FieldIndexNum;
import org.xtext.myCsv.InsertField;
import org.xtext.myCsv.InsertLine;
import org.xtext.myCsv.LineIndexCond;
import org.xtext.myCsv.LineIndexNum;
import org.xtext.myCsv.LitteralFloat;
import org.xtext.myCsv.LitteralInt;
import org.xtext.myCsv.LitteralString;
import org.xtext.myCsv.Load;
import org.xtext.myCsv.ModifyCell;
import org.xtext.myCsv.ModifyField;
import org.xtext.myCsv.ModifyLine;
import org.xtext.myCsv.MultiplicativeExpression;
import org.xtext.myCsv.MultiplicativeExpressionRhs;
import org.xtext.myCsv.MyCsvPackage;
import org.xtext.myCsv.NbField;
import org.xtext.myCsv.NestedExpressionCalcul;
import org.xtext.myCsv.NestedLogExpression;
import org.xtext.myCsv.OrExpression;
import org.xtext.myCsv.Path;
import org.xtext.myCsv.PrintCell;
import org.xtext.myCsv.PrintExpr;
import org.xtext.myCsv.PrintField;
import org.xtext.myCsv.PrintLine;
import org.xtext.myCsv.PrintTable;
import org.xtext.myCsv.Program;
import org.xtext.myCsv.Projection;
import org.xtext.myCsv.RenameField;
import org.xtext.myCsv.Select;
import org.xtext.myCsv.Store;
import org.xtext.myCsv.UnaryExpression;
import org.xtext.myCsv.UnaryLogExpression;
import org.xtext.myCsv.Values;
import org.xtext.services.MyCsvGrammarAccess;

@SuppressWarnings("all")
public class MyCsvSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyCsvGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyCsvPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyCsvPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case MyCsvPackage.ADDITIVE_EXPRESSION_RHS:
				sequence_AdditiveExpressionRhs(context, (AdditiveExpressionRhs) semanticObject); 
				return; 
			case MyCsvPackage.AGGREGAT_EXPRESSION:
				sequence_AggregatExpression(context, (AggregatExpression) semanticObject); 
				return; 
			case MyCsvPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case MyCsvPackage.CELL_INDEX:
				sequence_CellIndex(context, (CellIndex) semanticObject); 
				return; 
			case MyCsvPackage.DELETE_FIELD:
				sequence_DeleteField(context, (DeleteField) semanticObject); 
				return; 
			case MyCsvPackage.DELETE_LINE:
				sequence_DeleteLine(context, (DeleteLine) semanticObject); 
				return; 
			case MyCsvPackage.EXPORT_JSON:
				sequence_ExportJson(context, (ExportJson) semanticObject); 
				return; 
			case MyCsvPackage.EXPRESSION_CALCUL:
				sequence_ExpressionCalcul(context, (ExpressionCalcul) semanticObject); 
				return; 
			case MyCsvPackage.EXPRESSION_LOG:
				sequence_ExpressionLog(context, (ExpressionLog) semanticObject); 
				return; 
			case MyCsvPackage.EXPRESSION_REL:
				sequence_ExpressionRel(context, (ExpressionRel) semanticObject); 
				return; 
			case MyCsvPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case MyCsvPackage.FIELD_INDEX_NAME:
				sequence_FieldIndexName(context, (FieldIndexName) semanticObject); 
				return; 
			case MyCsvPackage.FIELD_INDEX_NUM:
				sequence_FieldIndexNum(context, (FieldIndexNum) semanticObject); 
				return; 
			case MyCsvPackage.INSERT_FIELD:
				sequence_InsertField(context, (InsertField) semanticObject); 
				return; 
			case MyCsvPackage.INSERT_LINE:
				sequence_InsertLine(context, (InsertLine) semanticObject); 
				return; 
			case MyCsvPackage.LINE_INDEX_COND:
				sequence_LineIndexCond(context, (LineIndexCond) semanticObject); 
				return; 
			case MyCsvPackage.LINE_INDEX_NUM:
				sequence_LineIndexNum(context, (LineIndexNum) semanticObject); 
				return; 
			case MyCsvPackage.LITTERAL_FLOAT:
				sequence_LitteralFloat(context, (LitteralFloat) semanticObject); 
				return; 
			case MyCsvPackage.LITTERAL_INT:
				sequence_LitteralInt(context, (LitteralInt) semanticObject); 
				return; 
			case MyCsvPackage.LITTERAL_STRING:
				sequence_LitteralString(context, (LitteralString) semanticObject); 
				return; 
			case MyCsvPackage.LOAD:
				sequence_Load(context, (Load) semanticObject); 
				return; 
			case MyCsvPackage.MODIFY_CELL:
				sequence_ModifyCell(context, (ModifyCell) semanticObject); 
				return; 
			case MyCsvPackage.MODIFY_FIELD:
				sequence_ModifyField(context, (ModifyField) semanticObject); 
				return; 
			case MyCsvPackage.MODIFY_LINE:
				sequence_ModifyLine(context, (ModifyLine) semanticObject); 
				return; 
			case MyCsvPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case MyCsvPackage.MULTIPLICATIVE_EXPRESSION_RHS:
				sequence_MultiplicativeExpressionRhs(context, (MultiplicativeExpressionRhs) semanticObject); 
				return; 
			case MyCsvPackage.NB_FIELD:
				sequence_ExpressionCalculPrimary(context, (NbField) semanticObject); 
				return; 
			case MyCsvPackage.NESTED_EXPRESSION_CALCUL:
				sequence_NestedExpressionCalcul(context, (NestedExpressionCalcul) semanticObject); 
				return; 
			case MyCsvPackage.NESTED_LOG_EXPRESSION:
				sequence_NestedLogExpression(context, (NestedLogExpression) semanticObject); 
				return; 
			case MyCsvPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case MyCsvPackage.PATH:
				sequence_Path(context, (Path) semanticObject); 
				return; 
			case MyCsvPackage.PRINT_CELL:
				sequence_PrintCell(context, (PrintCell) semanticObject); 
				return; 
			case MyCsvPackage.PRINT_EXPR:
				sequence_PrintExpr(context, (PrintExpr) semanticObject); 
				return; 
			case MyCsvPackage.PRINT_FIELD:
				sequence_PrintField(context, (PrintField) semanticObject); 
				return; 
			case MyCsvPackage.PRINT_LINE:
				sequence_PrintLine(context, (PrintLine) semanticObject); 
				return; 
			case MyCsvPackage.PRINT_TABLE:
				sequence_Print(context, (PrintTable) semanticObject); 
				return; 
			case MyCsvPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MyCsvPackage.PROJECTION:
				sequence_Projection(context, (Projection) semanticObject); 
				return; 
			case MyCsvPackage.RENAME_FIELD:
				sequence_RenameField(context, (RenameField) semanticObject); 
				return; 
			case MyCsvPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case MyCsvPackage.STORE:
				sequence_Store(context, (Store) semanticObject); 
				return; 
			case MyCsvPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case MyCsvPackage.UNARY_LOG_EXPRESSION:
				sequence_UnaryLogExpression(context, (UnaryLogExpression) semanticObject); 
				return; 
			case MyCsvPackage.VALUES:
				sequence_Values(context, (Values) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdditiveExpressionRhs returns AdditiveExpressionRhs
	 *
	 * Constraint:
	 *     (op=BinOpAdd rhs=MultiplicativeExpression)
	 */
	protected void sequence_AdditiveExpressionRhs(ISerializationContext context, AdditiveExpressionRhs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.ADDITIVE_EXPRESSION_RHS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.ADDITIVE_EXPRESSION_RHS__OP));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.ADDITIVE_EXPRESSION_RHS__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.ADDITIVE_EXPRESSION_RHS__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExpressionRhsAccess().getOpBinOpAddEnumRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAdditiveExpressionRhsAccess().getRhsMultiplicativeExpressionParserRuleCall_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveExpression returns AdditiveExpression
	 *
	 * Constraint:
	 *     (lhs=MultiplicativeExpression rhs+=AdditiveExpressionRhs*)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionCalculPrimary returns AggregatExpression
	 *     AggregatExpression returns AggregatExpression
	 *
	 * Constraint:
	 *     (aggregatOp=Aggregat arg=Field)
	 */
	protected void sequence_AggregatExpression(ISerializationContext context, AggregatExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.AGGREGAT_EXPRESSION__AGGREGAT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.AGGREGAT_EXPRESSION__AGGREGAT_OP));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.AGGREGAT_EXPRESSION__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.AGGREGAT_EXPRESSION__ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAggregatExpressionAccess().getAggregatOpAggregatEnumRuleCall_0_0(), semanticObject.getAggregatOp());
		feeder.accept(grammarAccess.getAggregatExpressionAccess().getArgFieldParserRuleCall_1_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns AndExpression
	 *
	 * Constraint:
	 *     (lhs=UnaryLogExpression rhs+=UnaryLogExpression*)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CellIndex returns CellIndex
	 *
	 * Constraint:
	 *     (line=INT (colnum=INT | colname=Field))
	 */
	protected void sequence_CellIndex(ISerializationContext context, CellIndex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeleteField
	 *     Delete returns DeleteField
	 *     DeleteField returns DeleteField
	 *
	 * Constraint:
	 *     fields=FieldIndex
	 */
	protected void sequence_DeleteField(ISerializationContext context, DeleteField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.DELETE_FIELD__FIELDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.DELETE_FIELD__FIELDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteFieldAccess().getFieldsFieldIndexParserRuleCall_1_0(), semanticObject.getFields());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeleteLine
	 *     Delete returns DeleteLine
	 *     DeleteLine returns DeleteLine
	 *
	 * Constraint:
	 *     lines=LineIndex
	 */
	protected void sequence_DeleteLine(ISerializationContext context, DeleteLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.DELETE_LINE__LINES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.DELETE_LINE__LINES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteLineAccess().getLinesLineIndexParserRuleCall_1_0(), semanticObject.getLines());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExportJson
	 *     ExportJson returns ExportJson
	 *
	 * Constraint:
	 *     path=Path
	 */
	protected void sequence_ExportJson(ISerializationContext context, ExportJson semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.EXPORT_JSON__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.EXPORT_JSON__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportJsonAccess().getPathPathParserRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionCalculPrimary returns NbField
	 *
	 * Constraint:
	 *     {NbField}
	 */
	protected void sequence_ExpressionCalculPrimary(ISerializationContext context, NbField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns ExpressionCalcul
	 *     ExpressionCalcul returns ExpressionCalcul
	 *
	 * Constraint:
	 *     expr=AdditiveExpression
	 */
	protected void sequence_ExpressionCalcul(ISerializationContext context, ExpressionCalcul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.EXPRESSION_CALCUL__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.EXPRESSION_CALCUL__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionCalculAccess().getExprAdditiveExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionLog returns ExpressionLog
	 *
	 * Constraint:
	 *     expr=OrExpression
	 */
	protected void sequence_ExpressionLog(ISerializationContext context, ExpressionLog semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.EXPRESSION_LOG__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.EXPRESSION_LOG__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLogAccess().getExprOrExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionLogPrimary returns ExpressionRel
	 *     ExpressionRel returns ExpressionRel
	 *
	 * Constraint:
	 *     (field=Field op=BinOpRel val=Value)
	 */
	protected void sequence_ExpressionRel(ISerializationContext context, ExpressionRel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.EXPRESSION_REL__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.EXPRESSION_REL__FIELD));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.EXPRESSION_REL__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.EXPRESSION_REL__OP));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.EXPRESSION_REL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.EXPRESSION_REL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionRelAccess().getFieldFieldParserRuleCall_0_0(), semanticObject.getField());
		feeder.accept(grammarAccess.getExpressionRelAccess().getOpBinOpRelEnumRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getExpressionRelAccess().getValValueParserRuleCall_2_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FieldIndex returns FieldIndexName
	 *     FieldIndexName returns FieldIndexName
	 *
	 * Constraint:
	 *     fields+=Field+
	 */
	protected void sequence_FieldIndexName(ISerializationContext context, FieldIndexName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FieldIndex returns FieldIndexNum
	 *     FieldIndexNum returns FieldIndexNum
	 *
	 * Constraint:
	 *     columns+=INT+
	 */
	protected void sequence_FieldIndexNum(ISerializationContext context, FieldIndexNum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     value=ID
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.FIELD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.FIELD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getValueIDTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns InsertField
	 *     Insert returns InsertField
	 *     InsertField returns InsertField
	 *
	 * Constraint:
	 *     (fieldname=Field values=Values)
	 */
	protected void sequence_InsertField(ISerializationContext context, InsertField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.INSERT_FIELD__FIELDNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.INSERT_FIELD__FIELDNAME));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.INSERT__VALUES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.INSERT__VALUES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInsertFieldAccess().getFieldnameFieldParserRuleCall_1_0(), semanticObject.getFieldname());
		feeder.accept(grammarAccess.getInsertFieldAccess().getValuesValuesParserRuleCall_3_0(), semanticObject.getValues());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns InsertLine
	 *     Insert returns InsertLine
	 *     InsertLine returns InsertLine
	 *
	 * Constraint:
	 *     values=Values
	 */
	protected void sequence_InsertLine(ISerializationContext context, InsertLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.INSERT__VALUES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.INSERT__VALUES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInsertLineAccess().getValuesValuesParserRuleCall_1_0(), semanticObject.getValues());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LineIndex returns LineIndexCond
	 *     LineIndexCond returns LineIndexCond
	 *
	 * Constraint:
	 *     cond=ExpressionLog
	 */
	protected void sequence_LineIndexCond(ISerializationContext context, LineIndexCond semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.LINE_INDEX_COND__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.LINE_INDEX_COND__COND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLineIndexCondAccess().getCondExpressionLogParserRuleCall_0(), semanticObject.getCond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LineIndex returns LineIndexNum
	 *     LineIndexNum returns LineIndexNum
	 *
	 * Constraint:
	 *     lines+=INT+
	 */
	protected void sequence_LineIndexNum(ISerializationContext context, LineIndexNum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionCalculPrimary returns LitteralFloat
	 *     LitteralFloat returns LitteralFloat
	 *
	 * Constraint:
	 *     val=FLOAT
	 */
	protected void sequence_LitteralFloat(ISerializationContext context, LitteralFloat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.LITTERAL_FLOAT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.LITTERAL_FLOAT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLitteralFloatAccess().getValFLOATParserRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionCalculPrimary returns LitteralInt
	 *     LitteralInt returns LitteralInt
	 *
	 * Constraint:
	 *     val=INT
	 */
	protected void sequence_LitteralInt(ISerializationContext context, LitteralInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.LITTERAL_INT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.LITTERAL_INT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLitteralIntAccess().getValINTTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns LitteralString
	 *     LitteralString returns LitteralString
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_LitteralString(ISerializationContext context, LitteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.LITTERAL_STRING__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.LITTERAL_STRING__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLitteralStringAccess().getValSTRINGTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Load
	 *     Load returns Load
	 *
	 * Constraint:
	 *     (path=Path (sepDefined?='sep' sep=STRING)? noHeader?='no'?)
	 */
	protected void sequence_Load(ISerializationContext context, Load semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ModifyCell
	 *     Modify returns ModifyCell
	 *     ModifyCell returns ModifyCell
	 *
	 * Constraint:
	 *     (cell=CellIndex value=Value)
	 */
	protected void sequence_ModifyCell(ISerializationContext context, ModifyCell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.MODIFY_CELL__CELL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.MODIFY_CELL__CELL));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.MODIFY_CELL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.MODIFY_CELL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModifyCellAccess().getCellCellIndexParserRuleCall_1_0(), semanticObject.getCell());
		feeder.accept(grammarAccess.getModifyCellAccess().getValueValueParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ModifyField
	 *     Modify returns ModifyField
	 *     ModifyField returns ModifyField
	 *
	 * Constraint:
	 *     (fields=FieldIndex values=Values)
	 */
	protected void sequence_ModifyField(ISerializationContext context, ModifyField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.MODIFY_FIELD__FIELDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.MODIFY_FIELD__FIELDS));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.MODIFY_FIELD__VALUES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.MODIFY_FIELD__VALUES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModifyFieldAccess().getFieldsFieldIndexParserRuleCall_1_0(), semanticObject.getFields());
		feeder.accept(grammarAccess.getModifyFieldAccess().getValuesValuesParserRuleCall_3_0(), semanticObject.getValues());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ModifyLine
	 *     Modify returns ModifyLine
	 *     ModifyLine returns ModifyLine
	 *
	 * Constraint:
	 *     (lines=LineIndex values=Values)
	 */
	protected void sequence_ModifyLine(ISerializationContext context, ModifyLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.MODIFY_LINE__LINES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.MODIFY_LINE__LINES));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.MODIFY_LINE__VALUES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.MODIFY_LINE__VALUES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModifyLineAccess().getLinesLineIndexParserRuleCall_1_0(), semanticObject.getLines());
		feeder.accept(grammarAccess.getModifyLineAccess().getValuesValuesParserRuleCall_3_0(), semanticObject.getValues());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpressionRhs returns MultiplicativeExpressionRhs
	 *
	 * Constraint:
	 *     (op=BinOpMult rhs=UnaryExpression)
	 */
	protected void sequence_MultiplicativeExpressionRhs(ISerializationContext context, MultiplicativeExpressionRhs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.MULTIPLICATIVE_EXPRESSION_RHS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.MULTIPLICATIVE_EXPRESSION_RHS__OP));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.MULTIPLICATIVE_EXPRESSION_RHS__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.MULTIPLICATIVE_EXPRESSION_RHS__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExpressionRhsAccess().getOpBinOpMultEnumRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMultiplicativeExpressionRhsAccess().getRhsUnaryExpressionParserRuleCall_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (lhs=UnaryExpression rhs+=MultiplicativeExpressionRhs*)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionCalculPrimary returns NestedExpressionCalcul
	 *     NestedExpressionCalcul returns NestedExpressionCalcul
	 *
	 * Constraint:
	 *     expr=ExpressionCalcul
	 */
	protected void sequence_NestedExpressionCalcul(ISerializationContext context, NestedExpressionCalcul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.NESTED_EXPRESSION_CALCUL__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.NESTED_EXPRESSION_CALCUL__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNestedExpressionCalculAccess().getExprExpressionCalculParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionLogPrimary returns NestedLogExpression
	 *     NestedLogExpression returns NestedLogExpression
	 *
	 * Constraint:
	 *     expr=ExpressionLog
	 */
	protected void sequence_NestedLogExpression(ISerializationContext context, NestedLogExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.NESTED_LOG_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.NESTED_LOG_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNestedLogExpressionAccess().getExprExpressionLogParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OrExpression returns OrExpression
	 *
	 * Constraint:
	 *     (lhs=AndExpression rhs+=AndExpression*)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Path returns Path
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Path(ISerializationContext context, Path semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.PATH__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.PATH__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintCell
	 *     Print returns PrintCell
	 *     PrintCell returns PrintCell
	 *
	 * Constraint:
	 *     cell=CellIndex
	 */
	protected void sequence_PrintCell(ISerializationContext context, PrintCell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.PRINT_CELL__CELL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.PRINT_CELL__CELL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintCellAccess().getCellCellIndexParserRuleCall_1_0(), semanticObject.getCell());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintExpr
	 *     Print returns PrintExpr
	 *     PrintExpr returns PrintExpr
	 *
	 * Constraint:
	 *     exp=Value
	 */
	protected void sequence_PrintExpr(ISerializationContext context, PrintExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.PRINT_EXPR__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.PRINT_EXPR__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintExprAccess().getExpValueParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintField
	 *     Print returns PrintField
	 *     PrintField returns PrintField
	 *
	 * Constraint:
	 *     fields=FieldIndex
	 */
	protected void sequence_PrintField(ISerializationContext context, PrintField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.PRINT_FIELD__FIELDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.PRINT_FIELD__FIELDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintFieldAccess().getFieldsFieldIndexParserRuleCall_1_0(), semanticObject.getFields());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintLine
	 *     Print returns PrintLine
	 *     PrintLine returns PrintLine
	 *
	 * Constraint:
	 *     lines=LineIndex
	 */
	protected void sequence_PrintLine(ISerializationContext context, PrintLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.PRINT_LINE__LINES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.PRINT_LINE__LINES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintLineAccess().getLinesLineIndexParserRuleCall_1_0(), semanticObject.getLines());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintTable
	 *     Print returns PrintTable
	 *
	 * Constraint:
	 *     {PrintTable}
	 */
	protected void sequence_Print(ISerializationContext context, PrintTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     stmts+=Statement+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Projection
	 *     Projection returns Projection
	 *
	 * Constraint:
	 *     field=FieldIndex
	 */
	protected void sequence_Projection(ISerializationContext context, Projection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.PROJECTION__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.PROJECTION__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProjectionAccess().getFieldFieldIndexParserRuleCall_1_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RenameField
	 *     RenameField returns RenameField
	 *
	 * Constraint:
	 *     (last_field=Field new_field=Field)
	 */
	protected void sequence_RenameField(ISerializationContext context, RenameField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.RENAME_FIELD__LAST_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.RENAME_FIELD__LAST_FIELD));
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.RENAME_FIELD__NEW_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.RENAME_FIELD__NEW_FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRenameFieldAccess().getLast_fieldFieldParserRuleCall_2_0(), semanticObject.getLast_field());
		feeder.accept(grammarAccess.getRenameFieldAccess().getNew_fieldFieldParserRuleCall_4_0(), semanticObject.getNew_field());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Select
	 *     Select returns Select
	 *
	 * Constraint:
	 *     line=LineIndex
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyCsvPackage.Literals.SELECT__LINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyCsvPackage.Literals.SELECT__LINE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectAccess().getLineLineIndexParserRuleCall_1_0(), semanticObject.getLine());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Store
	 *     Store returns Store
	 *
	 * Constraint:
	 *     (path=Path (sepDefined?='sep' sep=STRING)? noHeader?='no'?)
	 */
	protected void sequence_Store(ISerializationContext context, Store semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (op?='-'? expr=ExpressionCalculPrimary)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryLogExpression returns UnaryLogExpression
	 *
	 * Constraint:
	 *     (not?='not'? expr=ExpressionLogPrimary)
	 */
	protected void sequence_UnaryLogExpression(ISerializationContext context, UnaryLogExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Values returns Values
	 *
	 * Constraint:
	 *     (values+=Value values+=Value*)
	 */
	protected void sequence_Values(ISerializationContext context, Values semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

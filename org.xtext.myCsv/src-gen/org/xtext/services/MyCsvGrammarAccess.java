/*
 * generated by Xtext 2.23.0
 */
package org.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MyCsvGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Program");
		private final Assignment cStmtsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStmtsStatementParserRuleCall_0 = (RuleCall)cStmtsAssignment.eContents().get(0);
		
		//// Program
		//Program:
		//	stmts+=Statement+;
		@Override public ParserRule getRule() { return rule; }
		
		//stmts+=Statement+
		public Assignment getStmtsAssignment() { return cStmtsAssignment; }
		
		//Statement
		public RuleCall getStmtsStatementParserRuleCall_0() { return cStmtsStatementParserRuleCall_0; }
	}
	public class LineIndexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.LineIndex");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLineIndexCondParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLineIndexNumParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Useful indexes in CSV world
		//LineIndex:
		//	LineIndexCond | LineIndexNum;
		@Override public ParserRule getRule() { return rule; }
		
		//LineIndexCond | LineIndexNum
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LineIndexCond
		public RuleCall getLineIndexCondParserRuleCall_0() { return cLineIndexCondParserRuleCall_0; }
		
		//LineIndexNum
		public RuleCall getLineIndexNumParserRuleCall_1() { return cLineIndexNumParserRuleCall_1; }
	}
	public class LineIndexCondElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.LineIndexCond");
		private final Assignment cCondAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCondExpressionLogParserRuleCall_0 = (RuleCall)cCondAssignment.eContents().get(0);
		
		//LineIndexCond:
		//	cond=ExpressionLog;
		@Override public ParserRule getRule() { return rule; }
		
		//cond=ExpressionLog
		public Assignment getCondAssignment() { return cCondAssignment; }
		
		//ExpressionLog
		public RuleCall getCondExpressionLogParserRuleCall_0() { return cCondExpressionLogParserRuleCall_0; }
	}
	public class LineIndexNumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.LineIndexNum");
		private final Assignment cLinesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cLinesINTTerminalRuleCall_0 = (RuleCall)cLinesAssignment.eContents().get(0);
		
		//LineIndexNum:
		//	lines+=INT+;
		@Override public ParserRule getRule() { return rule; }
		
		//lines+=INT+
		public Assignment getLinesAssignment() { return cLinesAssignment; }
		
		//INT
		public RuleCall getLinesINTTerminalRuleCall_0() { return cLinesINTTerminalRuleCall_0; }
	}
	public class FieldIndexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.FieldIndex");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFieldIndexNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFieldIndexNumParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FieldIndex:
		//	FieldIndexName | FieldIndexNum;
		@Override public ParserRule getRule() { return rule; }
		
		//FieldIndexName | FieldIndexNum
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FieldIndexName
		public RuleCall getFieldIndexNameParserRuleCall_0() { return cFieldIndexNameParserRuleCall_0; }
		
		//FieldIndexNum
		public RuleCall getFieldIndexNumParserRuleCall_1() { return cFieldIndexNumParserRuleCall_1; }
	}
	public class FieldIndexNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.FieldIndexName");
		private final Assignment cFieldsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cFieldsFieldParserRuleCall_0 = (RuleCall)cFieldsAssignment.eContents().get(0);
		
		//FieldIndexName:
		//	fields+=Field+;
		@Override public ParserRule getRule() { return rule; }
		
		//fields+=Field+
		public Assignment getFieldsAssignment() { return cFieldsAssignment; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_0() { return cFieldsFieldParserRuleCall_0; }
	}
	public class FieldIndexNumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.FieldIndexNum");
		private final Assignment cColumnsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cColumnsINTTerminalRuleCall_0 = (RuleCall)cColumnsAssignment.eContents().get(0);
		
		//FieldIndexNum:
		//	columns+=INT+;
		@Override public ParserRule getRule() { return rule; }
		
		//columns+=INT+
		public Assignment getColumnsAssignment() { return cColumnsAssignment; }
		
		//INT
		public RuleCall getColumnsINTTerminalRuleCall_0() { return cColumnsINTTerminalRuleCall_0; }
	}
	public class CellIndexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.CellIndex");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLineAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLineINTTerminalRuleCall_1_0 = (RuleCall)cLineAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cColnumAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cColnumINTTerminalRuleCall_3_0_0 = (RuleCall)cColnumAssignment_3_0.eContents().get(0);
		private final Assignment cColnameAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cColnameFieldParserRuleCall_3_1_0 = (RuleCall)cColnameAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//CellIndex:
		//	'(' line=INT ',' (colnum=INT | colname=Field) ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' line=INT ',' (colnum=INT | colname=Field) ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//line=INT
		public Assignment getLineAssignment_1() { return cLineAssignment_1; }
		
		//INT
		public RuleCall getLineINTTerminalRuleCall_1_0() { return cLineINTTerminalRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//(colnum=INT | colname=Field)
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//colnum=INT
		public Assignment getColnumAssignment_3_0() { return cColnumAssignment_3_0; }
		
		//INT
		public RuleCall getColnumINTTerminalRuleCall_3_0_0() { return cColnumINTTerminalRuleCall_3_0_0; }
		
		//colname=Field
		public Assignment getColnameAssignment_3_1() { return cColnameAssignment_3_1; }
		
		//Field
		public RuleCall getColnameFieldParserRuleCall_3_1_0() { return cColnameFieldParserRuleCall_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpressionCalculParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLitteralStringParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Common arguments
		//Value:
		//	ExpressionCalcul | LitteralString;
		@Override public ParserRule getRule() { return rule; }
		
		//ExpressionCalcul | LitteralString
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExpressionCalcul
		public RuleCall getExpressionCalculParserRuleCall_0() { return cExpressionCalculParserRuleCall_0; }
		
		//LitteralString
		public RuleCall getLitteralStringParserRuleCall_1() { return cLitteralStringParserRuleCall_1; }
	}
	public class ValuesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Values");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValuesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuesValueParserRuleCall_1_0 = (RuleCall)cValuesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cValuesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValuesValueParserRuleCall_2_1_0 = (RuleCall)cValuesAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Values:
		//	'['? values+=Value (';' values+=Value)* ']'?;
		@Override public ParserRule getRule() { return rule; }
		
		//'['? values+=Value (';' values+=Value)* ']'?
		public Group getGroup() { return cGroup; }
		
		//'['?
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//values+=Value
		public Assignment getValuesAssignment_1() { return cValuesAssignment_1; }
		
		//Value
		public RuleCall getValuesValueParserRuleCall_1_0() { return cValuesValueParserRuleCall_1_0; }
		
		//(';' values+=Value)*
		public Group getGroup_2() { return cGroup_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_0() { return cSemicolonKeyword_2_0; }
		
		//values+=Value
		public Assignment getValuesAssignment_2_1() { return cValuesAssignment_2_1; }
		
		//Value
		public RuleCall getValuesValueParserRuleCall_2_1_0() { return cValuesValueParserRuleCall_2_1_0; }
		
		//']'?
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Path");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Path:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Field");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueIDTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Field:
		//	value=ID
		//	// /!\ We don't accept numbers as Field names.
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//value=ID
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//ID
		public RuleCall getValueIDTerminalRuleCall_0() { return cValueIDTerminalRuleCall_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLoadParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStoreParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExportJsonParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cProjectionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSelectParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDeleteParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cInsertParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cModifyParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cPrintParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		
		//// Statements and primitives
		//Statement:
		//	Load
		//	| Store
		//	| ExportJson
		//	| Projection
		//	| Select
		//	| Delete
		//	| Insert
		//	| Modify
		//	| Print;
		@Override public ParserRule getRule() { return rule; }
		
		//Load | Store | ExportJson | Projection | Select | Delete | Insert | Modify | Print
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Load
		public RuleCall getLoadParserRuleCall_0() { return cLoadParserRuleCall_0; }
		
		//Store
		public RuleCall getStoreParserRuleCall_1() { return cStoreParserRuleCall_1; }
		
		//ExportJson
		public RuleCall getExportJsonParserRuleCall_2() { return cExportJsonParserRuleCall_2; }
		
		//Projection
		public RuleCall getProjectionParserRuleCall_3() { return cProjectionParserRuleCall_3; }
		
		//Select
		public RuleCall getSelectParserRuleCall_4() { return cSelectParserRuleCall_4; }
		
		//Delete
		public RuleCall getDeleteParserRuleCall_5() { return cDeleteParserRuleCall_5; }
		
		//Insert
		public RuleCall getInsertParserRuleCall_6() { return cInsertParserRuleCall_6; }
		
		//Modify
		public RuleCall getModifyParserRuleCall_7() { return cModifyParserRuleCall_7; }
		
		//Print
		public RuleCall getPrintParserRuleCall_8() { return cPrintParserRuleCall_8; }
	}
	public class LoadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Load");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLoadKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPathAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathPathParserRuleCall_1_0 = (RuleCall)cPathAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cSepDefinedAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cSepDefinedSepKeyword_2_0_0 = (Keyword)cSepDefinedAssignment_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cSepAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cSepSTRINGTerminalRuleCall_2_2_0 = (RuleCall)cSepAssignment_2_2.eContents().get(0);
		private final Assignment cNoHeaderAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cNoHeaderNoheaderKeyword_3_0 = (Keyword)cNoHeaderAssignment_3.eContents().get(0);
		
		//Load:
		//	'Load' path=Path (sepDefined?='sep' '=' sep=STRING)? noHeader?='noheader'?;
		@Override public ParserRule getRule() { return rule; }
		
		//'Load' path=Path (sepDefined?='sep' '=' sep=STRING)? noHeader?='noheader'?
		public Group getGroup() { return cGroup; }
		
		//'Load'
		public Keyword getLoadKeyword_0() { return cLoadKeyword_0; }
		
		//path=Path
		public Assignment getPathAssignment_1() { return cPathAssignment_1; }
		
		//Path
		public RuleCall getPathPathParserRuleCall_1_0() { return cPathPathParserRuleCall_1_0; }
		
		//(sepDefined?='sep' '=' sep=STRING)?
		public Group getGroup_2() { return cGroup_2; }
		
		//sepDefined?='sep'
		public Assignment getSepDefinedAssignment_2_0() { return cSepDefinedAssignment_2_0; }
		
		//'sep'
		public Keyword getSepDefinedSepKeyword_2_0_0() { return cSepDefinedSepKeyword_2_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_1() { return cEqualsSignKeyword_2_1; }
		
		//sep=STRING
		public Assignment getSepAssignment_2_2() { return cSepAssignment_2_2; }
		
		//STRING
		public RuleCall getSepSTRINGTerminalRuleCall_2_2_0() { return cSepSTRINGTerminalRuleCall_2_2_0; }
		
		//noHeader?='noheader'?
		public Assignment getNoHeaderAssignment_3() { return cNoHeaderAssignment_3; }
		
		//'noheader'
		public Keyword getNoHeaderNoheaderKeyword_3_0() { return cNoHeaderNoheaderKeyword_3_0; }
	}
	public class StoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Store");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStoreKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPathAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathPathParserRuleCall_1_0 = (RuleCall)cPathAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cSepDefinedAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cSepDefinedSepKeyword_2_0_0 = (Keyword)cSepDefinedAssignment_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cSepAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cSepSTRINGTerminalRuleCall_2_2_0 = (RuleCall)cSepAssignment_2_2.eContents().get(0);
		
		//Store:
		//	'Store' path=Path (sepDefined?='sep' '=' sep=STRING)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'Store' path=Path (sepDefined?='sep' '=' sep=STRING)?
		public Group getGroup() { return cGroup; }
		
		//'Store'
		public Keyword getStoreKeyword_0() { return cStoreKeyword_0; }
		
		//path=Path
		public Assignment getPathAssignment_1() { return cPathAssignment_1; }
		
		//Path
		public RuleCall getPathPathParserRuleCall_1_0() { return cPathPathParserRuleCall_1_0; }
		
		//(sepDefined?='sep' '=' sep=STRING)?
		public Group getGroup_2() { return cGroup_2; }
		
		//sepDefined?='sep'
		public Assignment getSepDefinedAssignment_2_0() { return cSepDefinedAssignment_2_0; }
		
		//'sep'
		public Keyword getSepDefinedSepKeyword_2_0_0() { return cSepDefinedSepKeyword_2_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_1() { return cEqualsSignKeyword_2_1; }
		
		//sep=STRING
		public Assignment getSepAssignment_2_2() { return cSepAssignment_2_2; }
		
		//STRING
		public RuleCall getSepSTRINGTerminalRuleCall_2_2_0() { return cSepSTRINGTerminalRuleCall_2_2_0; }
	}
	public class ExportJsonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ExportJson");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExportJsonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPathAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathPathParserRuleCall_1_0 = (RuleCall)cPathAssignment_1.eContents().get(0);
		
		//ExportJson:
		//	'ExportJson' path=Path;
		@Override public ParserRule getRule() { return rule; }
		
		//'ExportJson' path=Path
		public Group getGroup() { return cGroup; }
		
		//'ExportJson'
		public Keyword getExportJsonKeyword_0() { return cExportJsonKeyword_0; }
		
		//path=Path
		public Assignment getPathAssignment_1() { return cPathAssignment_1; }
		
		//Path
		public RuleCall getPathPathParserRuleCall_1_0() { return cPathPathParserRuleCall_1_0; }
	}
	public class ProjectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Projection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProjectionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFieldAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFieldFieldIndexParserRuleCall_1_0 = (RuleCall)cFieldAssignment_1.eContents().get(0);
		
		//Projection:
		//	'Projection' field=FieldIndex;
		@Override public ParserRule getRule() { return rule; }
		
		//'Projection' field=FieldIndex
		public Group getGroup() { return cGroup; }
		
		//'Projection'
		public Keyword getProjectionKeyword_0() { return cProjectionKeyword_0; }
		
		//field=FieldIndex
		public Assignment getFieldAssignment_1() { return cFieldAssignment_1; }
		
		//FieldIndex
		public RuleCall getFieldFieldIndexParserRuleCall_1_0() { return cFieldFieldIndexParserRuleCall_1_0; }
	}
	public class SelectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Select");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSelectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLineAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLineLineIndexParserRuleCall_1_0 = (RuleCall)cLineAssignment_1.eContents().get(0);
		
		//Select:
		//	'Select' line=LineIndex;
		@Override public ParserRule getRule() { return rule; }
		
		//'Select' line=LineIndex
		public Group getGroup() { return cGroup; }
		
		//'Select'
		public Keyword getSelectKeyword_0() { return cSelectKeyword_0; }
		
		//line=LineIndex
		public Assignment getLineAssignment_1() { return cLineAssignment_1; }
		
		//LineIndex
		public RuleCall getLineLineIndexParserRuleCall_1_0() { return cLineLineIndexParserRuleCall_1_0; }
	}
	public class DeleteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Delete");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDeleteKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cDeleteLineParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cDeleteFieldParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//Delete:
		//	'Delete' (DeleteLine | DeleteField);
		@Override public ParserRule getRule() { return rule; }
		
		//'Delete' (DeleteLine | DeleteField)
		public Group getGroup() { return cGroup; }
		
		//'Delete'
		public Keyword getDeleteKeyword_0() { return cDeleteKeyword_0; }
		
		//(DeleteLine | DeleteField)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//DeleteLine
		public RuleCall getDeleteLineParserRuleCall_1_0() { return cDeleteLineParserRuleCall_1_0; }
		
		//DeleteField
		public RuleCall getDeleteFieldParserRuleCall_1_1() { return cDeleteFieldParserRuleCall_1_1; }
	}
	public class DeleteLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.DeleteLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLinesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLinesLineIndexParserRuleCall_1_0 = (RuleCall)cLinesAssignment_1.eContents().get(0);
		
		//DeleteLine:
		//	'line' lines=LineIndex;
		@Override public ParserRule getRule() { return rule; }
		
		//'line' lines=LineIndex
		public Group getGroup() { return cGroup; }
		
		//'line'
		public Keyword getLineKeyword_0() { return cLineKeyword_0; }
		
		//lines=LineIndex
		public Assignment getLinesAssignment_1() { return cLinesAssignment_1; }
		
		//LineIndex
		public RuleCall getLinesLineIndexParserRuleCall_1_0() { return cLinesLineIndexParserRuleCall_1_0; }
	}
	public class DeleteFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.DeleteField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFieldKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFieldsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFieldsFieldIndexParserRuleCall_1_0 = (RuleCall)cFieldsAssignment_1.eContents().get(0);
		
		//DeleteField:
		//	'field' fields=FieldIndex;
		@Override public ParserRule getRule() { return rule; }
		
		//'field' fields=FieldIndex
		public Group getGroup() { return cGroup; }
		
		//'field'
		public Keyword getFieldKeyword_0() { return cFieldKeyword_0; }
		
		//fields=FieldIndex
		public Assignment getFieldsAssignment_1() { return cFieldsAssignment_1; }
		
		//FieldIndex
		public RuleCall getFieldsFieldIndexParserRuleCall_1_0() { return cFieldsFieldIndexParserRuleCall_1_0; }
	}
	public class InsertElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Insert");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInsertKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cInsertLineParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cInsertFieldParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//Insert:
		//	'Insert' (InsertLine | InsertField);
		@Override public ParserRule getRule() { return rule; }
		
		//'Insert' (InsertLine | InsertField)
		public Group getGroup() { return cGroup; }
		
		//'Insert'
		public Keyword getInsertKeyword_0() { return cInsertKeyword_0; }
		
		//(InsertLine | InsertField)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//InsertLine
		public RuleCall getInsertLineParserRuleCall_1_0() { return cInsertLineParserRuleCall_1_0; }
		
		//InsertField
		public RuleCall getInsertFieldParserRuleCall_1_1() { return cInsertFieldParserRuleCall_1_1; }
	}
	public class InsertLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.InsertLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValuesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuesValuesParserRuleCall_1_0 = (RuleCall)cValuesAssignment_1.eContents().get(0);
		
		//InsertLine:
		//	'line' values=Values;
		@Override public ParserRule getRule() { return rule; }
		
		//'line' values=Values
		public Group getGroup() { return cGroup; }
		
		//'line'
		public Keyword getLineKeyword_0() { return cLineKeyword_0; }
		
		//values=Values
		public Assignment getValuesAssignment_1() { return cValuesAssignment_1; }
		
		//Values
		public RuleCall getValuesValuesParserRuleCall_1_0() { return cValuesValuesParserRuleCall_1_0; }
	}
	public class InsertFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.InsertField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFieldKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFieldnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFieldnameFieldParserRuleCall_1_0 = (RuleCall)cFieldnameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValuesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValuesValuesParserRuleCall_3_0 = (RuleCall)cValuesAssignment_3.eContents().get(0);
		
		//InsertField:
		//	'field' fieldname=Field ':' values=Values;
		@Override public ParserRule getRule() { return rule; }
		
		//'field' fieldname=Field ':' values=Values
		public Group getGroup() { return cGroup; }
		
		//'field'
		public Keyword getFieldKeyword_0() { return cFieldKeyword_0; }
		
		//fieldname=Field
		public Assignment getFieldnameAssignment_1() { return cFieldnameAssignment_1; }
		
		//Field
		public RuleCall getFieldnameFieldParserRuleCall_1_0() { return cFieldnameFieldParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//values=Values
		public Assignment getValuesAssignment_3() { return cValuesAssignment_3; }
		
		//Values
		public RuleCall getValuesValuesParserRuleCall_3_0() { return cValuesValuesParserRuleCall_3_0; }
	}
	public class ModifyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Modify");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModifyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cModifyLineParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cModifyFieldParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cModifyCellParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		
		//Modify:
		//	'Modify' (ModifyLine | ModifyField | ModifyCell);
		@Override public ParserRule getRule() { return rule; }
		
		//'Modify' (ModifyLine | ModifyField | ModifyCell)
		public Group getGroup() { return cGroup; }
		
		//'Modify'
		public Keyword getModifyKeyword_0() { return cModifyKeyword_0; }
		
		//(ModifyLine | ModifyField | ModifyCell)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//ModifyLine
		public RuleCall getModifyLineParserRuleCall_1_0() { return cModifyLineParserRuleCall_1_0; }
		
		//ModifyField
		public RuleCall getModifyFieldParserRuleCall_1_1() { return cModifyFieldParserRuleCall_1_1; }
		
		//ModifyCell
		public RuleCall getModifyCellParserRuleCall_1_2() { return cModifyCellParserRuleCall_1_2; }
	}
	public class ModifyLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ModifyLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLinesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLinesLineIndexParserRuleCall_1_0 = (RuleCall)cLinesAssignment_1.eContents().get(0);
		private final Keyword cWithKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValuesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValuesValuesParserRuleCall_3_0 = (RuleCall)cValuesAssignment_3.eContents().get(0);
		
		//ModifyLine:
		//	'line' lines=LineIndex 'with' values=Values;
		@Override public ParserRule getRule() { return rule; }
		
		//'line' lines=LineIndex 'with' values=Values
		public Group getGroup() { return cGroup; }
		
		//'line'
		public Keyword getLineKeyword_0() { return cLineKeyword_0; }
		
		//lines=LineIndex
		public Assignment getLinesAssignment_1() { return cLinesAssignment_1; }
		
		//LineIndex
		public RuleCall getLinesLineIndexParserRuleCall_1_0() { return cLinesLineIndexParserRuleCall_1_0; }
		
		//'with'
		public Keyword getWithKeyword_2() { return cWithKeyword_2; }
		
		//values=Values
		public Assignment getValuesAssignment_3() { return cValuesAssignment_3; }
		
		//Values
		public RuleCall getValuesValuesParserRuleCall_3_0() { return cValuesValuesParserRuleCall_3_0; }
	}
	public class ModifyFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ModifyField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFieldKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFieldsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFieldsFieldIndexParserRuleCall_1_0 = (RuleCall)cFieldsAssignment_1.eContents().get(0);
		private final Keyword cWithKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValuesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValuesValuesParserRuleCall_3_0 = (RuleCall)cValuesAssignment_3.eContents().get(0);
		
		//ModifyField:
		//	'field' fields=FieldIndex 'with' values=Values;
		@Override public ParserRule getRule() { return rule; }
		
		//'field' fields=FieldIndex 'with' values=Values
		public Group getGroup() { return cGroup; }
		
		//'field'
		public Keyword getFieldKeyword_0() { return cFieldKeyword_0; }
		
		//fields=FieldIndex
		public Assignment getFieldsAssignment_1() { return cFieldsAssignment_1; }
		
		//FieldIndex
		public RuleCall getFieldsFieldIndexParserRuleCall_1_0() { return cFieldsFieldIndexParserRuleCall_1_0; }
		
		//'with'
		public Keyword getWithKeyword_2() { return cWithKeyword_2; }
		
		//values=Values
		public Assignment getValuesAssignment_3() { return cValuesAssignment_3; }
		
		//Values
		public RuleCall getValuesValuesParserRuleCall_3_0() { return cValuesValuesParserRuleCall_3_0; }
	}
	public class ModifyCellElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ModifyCell");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCellKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCellAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCellCellIndexParserRuleCall_1_0 = (RuleCall)cCellAssignment_1.eContents().get(0);
		private final Keyword cWithKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueValueParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ModifyCell:
		//	'cell' cell=CellIndex 'with' value=Value;
		@Override public ParserRule getRule() { return rule; }
		
		//'cell' cell=CellIndex 'with' value=Value
		public Group getGroup() { return cGroup; }
		
		//'cell'
		public Keyword getCellKeyword_0() { return cCellKeyword_0; }
		
		//cell=CellIndex
		public Assignment getCellAssignment_1() { return cCellAssignment_1; }
		
		//CellIndex
		public RuleCall getCellCellIndexParserRuleCall_1_0() { return cCellCellIndexParserRuleCall_1_0; }
		
		//'with'
		public Keyword getWithKeyword_2() { return cWithKeyword_2; }
		
		//value=Value
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//Value
		public RuleCall getValueValueParserRuleCall_3_0() { return cValueValueParserRuleCall_3_0; }
	}
	public class PrintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Print");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPrintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cPrintLineParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cPrintFieldParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cPrintCellParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final Group cGroup_1_3 = (Group)cAlternatives_1.eContents().get(3);
		private final Action cPrintTableAction_1_3_0 = (Action)cGroup_1_3.eContents().get(0);
		private final RuleCall cPrintTableParserRuleCall_1_3_1 = (RuleCall)cGroup_1_3.eContents().get(1);
		private final RuleCall cPrintExprParserRuleCall_1_4 = (RuleCall)cAlternatives_1.eContents().get(4);
		
		//Print:
		//	'Print' (PrintLine | PrintField | PrintCell | {PrintTable} PrintTable | PrintExpr);
		@Override public ParserRule getRule() { return rule; }
		
		//'Print' (PrintLine | PrintField | PrintCell | {PrintTable} PrintTable | PrintExpr)
		public Group getGroup() { return cGroup; }
		
		//'Print'
		public Keyword getPrintKeyword_0() { return cPrintKeyword_0; }
		
		//(PrintLine | PrintField | PrintCell | {PrintTable} PrintTable | PrintExpr)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//PrintLine
		public RuleCall getPrintLineParserRuleCall_1_0() { return cPrintLineParserRuleCall_1_0; }
		
		//PrintField
		public RuleCall getPrintFieldParserRuleCall_1_1() { return cPrintFieldParserRuleCall_1_1; }
		
		//PrintCell
		public RuleCall getPrintCellParserRuleCall_1_2() { return cPrintCellParserRuleCall_1_2; }
		
		//{PrintTable} PrintTable
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//{PrintTable}
		public Action getPrintTableAction_1_3_0() { return cPrintTableAction_1_3_0; }
		
		//PrintTable
		public RuleCall getPrintTableParserRuleCall_1_3_1() { return cPrintTableParserRuleCall_1_3_1; }
		
		//PrintExpr
		public RuleCall getPrintExprParserRuleCall_1_4() { return cPrintExprParserRuleCall_1_4; }
	}
	public class PrintLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.PrintLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLinesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLinesLineIndexParserRuleCall_1_0 = (RuleCall)cLinesAssignment_1.eContents().get(0);
		
		//PrintLine:
		//	'line' lines=LineIndex;
		@Override public ParserRule getRule() { return rule; }
		
		//'line' lines=LineIndex
		public Group getGroup() { return cGroup; }
		
		//'line'
		public Keyword getLineKeyword_0() { return cLineKeyword_0; }
		
		//lines=LineIndex
		public Assignment getLinesAssignment_1() { return cLinesAssignment_1; }
		
		//LineIndex
		public RuleCall getLinesLineIndexParserRuleCall_1_0() { return cLinesLineIndexParserRuleCall_1_0; }
	}
	public class PrintFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.PrintField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFieldKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFieldsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFieldsFieldIndexParserRuleCall_1_0 = (RuleCall)cFieldsAssignment_1.eContents().get(0);
		
		//PrintField:
		//	'field' fields=FieldIndex;
		@Override public ParserRule getRule() { return rule; }
		
		//'field' fields=FieldIndex
		public Group getGroup() { return cGroup; }
		
		//'field'
		public Keyword getFieldKeyword_0() { return cFieldKeyword_0; }
		
		//fields=FieldIndex
		public Assignment getFieldsAssignment_1() { return cFieldsAssignment_1; }
		
		//FieldIndex
		public RuleCall getFieldsFieldIndexParserRuleCall_1_0() { return cFieldsFieldIndexParserRuleCall_1_0; }
	}
	public class PrintCellElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.PrintCell");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCellKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCellAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCellCellIndexParserRuleCall_1_0 = (RuleCall)cCellAssignment_1.eContents().get(0);
		
		//PrintCell:
		//	'cell' cell=CellIndex;
		@Override public ParserRule getRule() { return rule; }
		
		//'cell' cell=CellIndex
		public Group getGroup() { return cGroup; }
		
		//'cell'
		public Keyword getCellKeyword_0() { return cCellKeyword_0; }
		
		//cell=CellIndex
		public Assignment getCellAssignment_1() { return cCellAssignment_1; }
		
		//CellIndex
		public RuleCall getCellCellIndexParserRuleCall_1_0() { return cCellCellIndexParserRuleCall_1_0; }
	}
	public class PrintTableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.PrintTable");
		private final Keyword cTableKeyword = (Keyword)rule.eContents().get(1);
		
		//PrintTable:
		//	'table';
		@Override public ParserRule getRule() { return rule; }
		
		//'table'
		public Keyword getTableKeyword() { return cTableKeyword; }
	}
	public class PrintExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.PrintExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExprKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpValueParserRuleCall_1_0 = (RuleCall)cExpAssignment_1.eContents().get(0);
		
		//PrintExpr:
		//	'expr' exp=Value;
		@Override public ParserRule getRule() { return rule; }
		
		//'expr' exp=Value
		public Group getGroup() { return cGroup; }
		
		//'expr'
		public Keyword getExprKeyword_0() { return cExprKeyword_0; }
		
		//exp=Value
		public Assignment getExpAssignment_1() { return cExpAssignment_1; }
		
		//Value
		public RuleCall getExpValueParserRuleCall_1_0() { return cExpValueParserRuleCall_1_0; }
	}
	public class ExpressionLogElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ExpressionLog");
		private final Assignment cExprAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExprOrExpressionParserRuleCall_0 = (RuleCall)cExprAssignment.eContents().get(0);
		
		//// Logical expressions
		//ExpressionLog:
		//	expr=OrExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//expr=OrExpression
		public Assignment getExprAssignment() { return cExprAssignment; }
		
		//OrExpression
		public RuleCall getExprOrExpressionParserRuleCall_0() { return cExprOrExpressionParserRuleCall_0; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsAndExpressionParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cOrKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRhsAndExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0);
		
		//OrExpression:
		//	lhs=AndExpression ('or' rhs+=AndExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//lhs=AndExpression ('or' rhs+=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//lhs=AndExpression
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }
		
		//AndExpression
		public RuleCall getLhsAndExpressionParserRuleCall_0_0() { return cLhsAndExpressionParserRuleCall_0_0; }
		
		//('or' rhs+=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'or'
		public Keyword getOrKeyword_1_0() { return cOrKeyword_1_0; }
		
		//rhs+=AndExpression
		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; }
		
		//AndExpression
		public RuleCall getRhsAndExpressionParserRuleCall_1_1_0() { return cRhsAndExpressionParserRuleCall_1_1_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsUnaryLogExpressionParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cAndKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRhsUnaryLogExpressionParserRuleCall_1_1_0 = (RuleCall)cRhsAssignment_1_1.eContents().get(0);
		
		//AndExpression:
		//	lhs=UnaryLogExpression ('and' rhs+=UnaryLogExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//lhs=UnaryLogExpression ('and' rhs+=UnaryLogExpression)*
		public Group getGroup() { return cGroup; }
		
		//lhs=UnaryLogExpression
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }
		
		//UnaryLogExpression
		public RuleCall getLhsUnaryLogExpressionParserRuleCall_0_0() { return cLhsUnaryLogExpressionParserRuleCall_0_0; }
		
		//('and' rhs+=UnaryLogExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'and'
		public Keyword getAndKeyword_1_0() { return cAndKeyword_1_0; }
		
		//rhs+=UnaryLogExpression
		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; }
		
		//UnaryLogExpression
		public RuleCall getRhsUnaryLogExpressionParserRuleCall_1_1_0() { return cRhsUnaryLogExpressionParserRuleCall_1_1_0; }
	}
	public class UnaryLogExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.UnaryLogExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNotAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNotNotKeyword_0_0 = (Keyword)cNotAssignment_0.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionLogPrimaryParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//UnaryLogExpression:
		//	not?='not'? expr=ExpressionLogPrimary;
		@Override public ParserRule getRule() { return rule; }
		
		//not?='not'? expr=ExpressionLogPrimary
		public Group getGroup() { return cGroup; }
		
		//not?='not'?
		public Assignment getNotAssignment_0() { return cNotAssignment_0; }
		
		//'not'
		public Keyword getNotNotKeyword_0_0() { return cNotNotKeyword_0_0; }
		
		//expr=ExpressionLogPrimary
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//ExpressionLogPrimary
		public RuleCall getExprExpressionLogPrimaryParserRuleCall_1_0() { return cExprExpressionLogPrimaryParserRuleCall_1_0; }
	}
	public class ExpressionLogPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ExpressionLogPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpressionRelParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNestedLogExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ExpressionLogPrimary:
		//	ExpressionRel | NestedLogExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//ExpressionRel | NestedLogExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExpressionRel
		public RuleCall getExpressionRelParserRuleCall_0() { return cExpressionRelParserRuleCall_0; }
		
		//NestedLogExpression
		public RuleCall getNestedLogExpressionParserRuleCall_1() { return cNestedLogExpressionParserRuleCall_1; }
	}
	public class NestedLogExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.NestedLogExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionLogParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//NestedLogExpression:
		//	'(' expr=ExpressionLog ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' expr=ExpressionLog ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//expr=ExpressionLog
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//ExpressionLog
		public RuleCall getExprExpressionLogParserRuleCall_1_0() { return cExprExpressionLogParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class ExpressionRelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ExpressionRel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFieldAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFieldFieldParserRuleCall_0_0 = (RuleCall)cFieldAssignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpBinOpRelEnumRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cValAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValValueParserRuleCall_2_0 = (RuleCall)cValAssignment_2.eContents().get(0);
		
		//// Bridge between logical and numerical expressions
		//ExpressionRel:
		//	field=Field op=BinOpRel val=Value;
		@Override public ParserRule getRule() { return rule; }
		
		//field=Field op=BinOpRel val=Value
		public Group getGroup() { return cGroup; }
		
		//field=Field
		public Assignment getFieldAssignment_0() { return cFieldAssignment_0; }
		
		//Field
		public RuleCall getFieldFieldParserRuleCall_0_0() { return cFieldFieldParserRuleCall_0_0; }
		
		//op=BinOpRel
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }
		
		//BinOpRel
		public RuleCall getOpBinOpRelEnumRuleCall_1_0() { return cOpBinOpRelEnumRuleCall_1_0; }
		
		//val=Value
		public Assignment getValAssignment_2() { return cValAssignment_2; }
		
		//Value
		public RuleCall getValValueParserRuleCall_2_0() { return cValValueParserRuleCall_2_0; }
	}
	public class ExpressionCalculElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ExpressionCalcul");
		private final Assignment cExprAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExprAdditiveExpressionParserRuleCall_0 = (RuleCall)cExprAssignment.eContents().get(0);
		
		//// Numerical expressions
		//ExpressionCalcul:
		//	expr=AdditiveExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//expr=AdditiveExpression
		public Assignment getExprAssignment() { return cExprAssignment; }
		
		//AdditiveExpression
		public RuleCall getExprAdditiveExpressionParserRuleCall_0() { return cExprAdditiveExpressionParserRuleCall_0; }
	}
	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsMultiplicativeExpressionParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cRhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRhsAdditiveExpressionRhsParserRuleCall_1_0 = (RuleCall)cRhsAssignment_1.eContents().get(0);
		
		//AdditiveExpression:
		//	lhs=MultiplicativeExpression rhs+=AdditiveExpressionRhs*;
		@Override public ParserRule getRule() { return rule; }
		
		//lhs=MultiplicativeExpression rhs+=AdditiveExpressionRhs*
		public Group getGroup() { return cGroup; }
		
		//lhs=MultiplicativeExpression
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }
		
		//MultiplicativeExpression
		public RuleCall getLhsMultiplicativeExpressionParserRuleCall_0_0() { return cLhsMultiplicativeExpressionParserRuleCall_0_0; }
		
		//rhs+=AdditiveExpressionRhs*
		public Assignment getRhsAssignment_1() { return cRhsAssignment_1; }
		
		//AdditiveExpressionRhs
		public RuleCall getRhsAdditiveExpressionRhsParserRuleCall_1_0() { return cRhsAdditiveExpressionRhsParserRuleCall_1_0; }
	}
	public class AdditiveExpressionRhsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.AdditiveExpressionRhs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpBinOpAddEnumRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cRhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRhsMultiplicativeExpressionParserRuleCall_1_0 = (RuleCall)cRhsAssignment_1.eContents().get(0);
		
		//AdditiveExpressionRhs:
		//	op=BinOpAdd rhs=MultiplicativeExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//op=BinOpAdd rhs=MultiplicativeExpression
		public Group getGroup() { return cGroup; }
		
		//op=BinOpAdd
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//BinOpAdd
		public RuleCall getOpBinOpAddEnumRuleCall_0_0() { return cOpBinOpAddEnumRuleCall_0_0; }
		
		//rhs=MultiplicativeExpression
		public Assignment getRhsAssignment_1() { return cRhsAssignment_1; }
		
		//MultiplicativeExpression
		public RuleCall getRhsMultiplicativeExpressionParserRuleCall_1_0() { return cRhsMultiplicativeExpressionParserRuleCall_1_0; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsUnaryExpressionParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cRhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRhsMultiplicativeExpressionRhsParserRuleCall_1_0 = (RuleCall)cRhsAssignment_1.eContents().get(0);
		
		//MultiplicativeExpression:
		//	lhs=UnaryExpression rhs+=MultiplicativeExpressionRhs*;
		@Override public ParserRule getRule() { return rule; }
		
		//lhs=UnaryExpression rhs+=MultiplicativeExpressionRhs*
		public Group getGroup() { return cGroup; }
		
		//lhs=UnaryExpression
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }
		
		//UnaryExpression
		public RuleCall getLhsUnaryExpressionParserRuleCall_0_0() { return cLhsUnaryExpressionParserRuleCall_0_0; }
		
		//rhs+=MultiplicativeExpressionRhs*
		public Assignment getRhsAssignment_1() { return cRhsAssignment_1; }
		
		//MultiplicativeExpressionRhs
		public RuleCall getRhsMultiplicativeExpressionRhsParserRuleCall_1_0() { return cRhsMultiplicativeExpressionRhsParserRuleCall_1_0; }
	}
	public class MultiplicativeExpressionRhsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.MultiplicativeExpressionRhs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpBinOpMultEnumRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cRhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRhsUnaryExpressionParserRuleCall_1_0 = (RuleCall)cRhsAssignment_1.eContents().get(0);
		
		//MultiplicativeExpressionRhs:
		//	op=BinOpMult rhs=UnaryExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//op=BinOpMult rhs=UnaryExpression
		public Group getGroup() { return cGroup; }
		
		//op=BinOpMult
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//BinOpMult
		public RuleCall getOpBinOpMultEnumRuleCall_0_0() { return cOpBinOpMultEnumRuleCall_0_0; }
		
		//rhs=UnaryExpression
		public Assignment getRhsAssignment_1() { return cRhsAssignment_1; }
		
		//UnaryExpression
		public RuleCall getRhsUnaryExpressionParserRuleCall_1_0() { return cRhsUnaryExpressionParserRuleCall_1_0; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_0_0 = (Keyword)cOpAssignment_0.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionCalculPrimaryParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//UnaryExpression:
		//	op?='-'? expr=ExpressionCalculPrimary;
		@Override public ParserRule getRule() { return rule; }
		
		//op?='-'? expr=ExpressionCalculPrimary
		public Group getGroup() { return cGroup; }
		
		//op?='-'?
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_0_0() { return cOpHyphenMinusKeyword_0_0; }
		
		//expr=ExpressionCalculPrimary
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//ExpressionCalculPrimary
		public RuleCall getExprExpressionCalculPrimaryParserRuleCall_1_0() { return cExprExpressionCalculPrimaryParserRuleCall_1_0; }
	}
	public class ExpressionCalculPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.ExpressionCalculPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNbFieldAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cNbFieldParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cAggregatExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLitteralIntParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLitteralFloatParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNestedExpressionCalculParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//ExpressionCalculPrimary:
		//	{NbField} NbField | AggregatExpression | LitteralInt | LitteralFloat | NestedExpressionCalcul;
		@Override public ParserRule getRule() { return rule; }
		
		//{NbField} NbField | AggregatExpression | LitteralInt | LitteralFloat | NestedExpressionCalcul
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{NbField} NbField
		public Group getGroup_0() { return cGroup_0; }
		
		//{NbField}
		public Action getNbFieldAction_0_0() { return cNbFieldAction_0_0; }
		
		//NbField
		public RuleCall getNbFieldParserRuleCall_0_1() { return cNbFieldParserRuleCall_0_1; }
		
		//AggregatExpression
		public RuleCall getAggregatExpressionParserRuleCall_1() { return cAggregatExpressionParserRuleCall_1; }
		
		//LitteralInt
		public RuleCall getLitteralIntParserRuleCall_2() { return cLitteralIntParserRuleCall_2; }
		
		//LitteralFloat
		public RuleCall getLitteralFloatParserRuleCall_3() { return cLitteralFloatParserRuleCall_3; }
		
		//NestedExpressionCalcul
		public RuleCall getNestedExpressionCalculParserRuleCall_4() { return cNestedExpressionCalculParserRuleCall_4; }
	}
	public class AggregatExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.AggregatExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAggregatOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAggregatOpAggregatEnumRuleCall_0_0 = (RuleCall)cAggregatOpAssignment_0.eContents().get(0);
		private final Assignment cArgAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgFieldParserRuleCall_1_0 = (RuleCall)cArgAssignment_1.eContents().get(0);
		
		//AggregatExpression:
		//	aggregatOp=Aggregat arg=Field;
		@Override public ParserRule getRule() { return rule; }
		
		//aggregatOp=Aggregat arg=Field
		public Group getGroup() { return cGroup; }
		
		//aggregatOp=Aggregat
		public Assignment getAggregatOpAssignment_0() { return cAggregatOpAssignment_0; }
		
		//Aggregat
		public RuleCall getAggregatOpAggregatEnumRuleCall_0_0() { return cAggregatOpAggregatEnumRuleCall_0_0; }
		
		//arg=Field
		public Assignment getArgAssignment_1() { return cArgAssignment_1; }
		
		//Field
		public RuleCall getArgFieldParserRuleCall_1_0() { return cArgFieldParserRuleCall_1_0; }
	}
	public class LitteralIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.LitteralInt");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValINTTerminalRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//LitteralInt:
		//	val=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//val=INT
		public Assignment getValAssignment() { return cValAssignment; }
		
		//INT
		public RuleCall getValINTTerminalRuleCall_0() { return cValINTTerminalRuleCall_0; }
	}
	public class LitteralFloatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.LitteralFloat");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValFLOATParserRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//LitteralFloat:
		//	val=FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//val=FLOAT
		public Assignment getValAssignment() { return cValAssignment; }
		
		//FLOAT
		public RuleCall getValFLOATParserRuleCall_0() { return cValFLOATParserRuleCall_0; }
	}
	public class LitteralStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.LitteralString");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValSTRINGTerminalRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//LitteralString:
		//	val=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//val=STRING
		public Assignment getValAssignment() { return cValAssignment; }
		
		//STRING
		public RuleCall getValSTRINGTerminalRuleCall_0() { return cValSTRINGTerminalRuleCall_0; }
	}
	public class NestedExpressionCalculElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.NestedExpressionCalcul");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionCalculParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//NestedExpressionCalcul:
		//	'(' expr=ExpressionCalcul ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' expr=ExpressionCalcul ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//expr=ExpressionCalcul
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }
		
		//ExpressionCalcul
		public RuleCall getExprExpressionCalculParserRuleCall_1_0() { return cExprExpressionCalculParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class NbFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.NbField");
		private final Keyword cNbFieldKeyword = (Keyword)rule.eContents().get(1);
		
		//NbField:
		//	'NbField';
		@Override public ParserRule getRule() { return rule; }
		
		//'NbField'
		public Keyword getNbFieldKeyword() { return cNbFieldKeyword; }
	}
	public class FLOATElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.FLOAT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//FLOAT ecore::EFloat:
		//	INT '.' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT '.' INT
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	
	public class BinOpRelElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.BinOpRel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGtEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGtGreaterThanSignKeyword_0_0 = (Keyword)cGtEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLtEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLtLessThanSignKeyword_1_0 = (Keyword)cLtEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGeEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGeGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGeEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLeEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLeLessThanSignEqualsSignKeyword_3_0 = (Keyword)cLeEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cEqEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cEqEqualsSignEqualsSignKeyword_4_0 = (Keyword)cEqEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNeqEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNeqExclamationMarkEqualsSignKeyword_5_0 = (Keyword)cNeqEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum BinOpRel:
		//	gt='>' |
		//	lt='<' |
		//	ge='>=' |
		//	le='<=' |
		//	eq='==' |
		//	neq='!=';
		public EnumRule getRule() { return rule; }
		
		//gt='>' | lt='<' | ge='>=' | le='<=' | eq='==' | neq='!='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//gt='>'
		public EnumLiteralDeclaration getGtEnumLiteralDeclaration_0() { return cGtEnumLiteralDeclaration_0; }
		
		//'>'
		public Keyword getGtGreaterThanSignKeyword_0_0() { return cGtGreaterThanSignKeyword_0_0; }
		
		//lt='<'
		public EnumLiteralDeclaration getLtEnumLiteralDeclaration_1() { return cLtEnumLiteralDeclaration_1; }
		
		//'<'
		public Keyword getLtLessThanSignKeyword_1_0() { return cLtLessThanSignKeyword_1_0; }
		
		//ge='>='
		public EnumLiteralDeclaration getGeEnumLiteralDeclaration_2() { return cGeEnumLiteralDeclaration_2; }
		
		//'>='
		public Keyword getGeGreaterThanSignEqualsSignKeyword_2_0() { return cGeGreaterThanSignEqualsSignKeyword_2_0; }
		
		//le='<='
		public EnumLiteralDeclaration getLeEnumLiteralDeclaration_3() { return cLeEnumLiteralDeclaration_3; }
		
		//'<='
		public Keyword getLeLessThanSignEqualsSignKeyword_3_0() { return cLeLessThanSignEqualsSignKeyword_3_0; }
		
		//eq='=='
		public EnumLiteralDeclaration getEqEnumLiteralDeclaration_4() { return cEqEnumLiteralDeclaration_4; }
		
		//'=='
		public Keyword getEqEqualsSignEqualsSignKeyword_4_0() { return cEqEqualsSignEqualsSignKeyword_4_0; }
		
		//neq='!='
		public EnumLiteralDeclaration getNeqEnumLiteralDeclaration_5() { return cNeqEnumLiteralDeclaration_5; }
		
		//'!='
		public Keyword getNeqExclamationMarkEqualsSignKeyword_5_0() { return cNeqExclamationMarkEqualsSignKeyword_5_0; }
	}
	public class AggregatElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.Aggregat");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCountEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCountCountKeyword_0_0 = (Keyword)cCountEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSumEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSumSumKeyword_1_0 = (Keyword)cSumEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cProductEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cProductProductKeyword_2_0 = (Keyword)cProductEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMeanEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMeanMeanKeyword_3_0 = (Keyword)cMeanEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Aggregat:
		//	count='Count' |
		//	sum='Sum' |
		//	product='Product' |
		//	mean='Mean';
		public EnumRule getRule() { return rule; }
		
		//count='Count' | sum='Sum' | product='Product' | mean='Mean'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//count='Count'
		public EnumLiteralDeclaration getCountEnumLiteralDeclaration_0() { return cCountEnumLiteralDeclaration_0; }
		
		//'Count'
		public Keyword getCountCountKeyword_0_0() { return cCountCountKeyword_0_0; }
		
		//sum='Sum'
		public EnumLiteralDeclaration getSumEnumLiteralDeclaration_1() { return cSumEnumLiteralDeclaration_1; }
		
		//'Sum'
		public Keyword getSumSumKeyword_1_0() { return cSumSumKeyword_1_0; }
		
		//product='Product'
		public EnumLiteralDeclaration getProductEnumLiteralDeclaration_2() { return cProductEnumLiteralDeclaration_2; }
		
		//'Product'
		public Keyword getProductProductKeyword_2_0() { return cProductProductKeyword_2_0; }
		
		//mean='Mean'
		public EnumLiteralDeclaration getMeanEnumLiteralDeclaration_3() { return cMeanEnumLiteralDeclaration_3; }
		
		//'Mean'
		public Keyword getMeanMeanKeyword_3_0() { return cMeanMeanKeyword_3_0; }
	}
	public class BinOpAddElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.BinOpAdd");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPlusEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPlusPlusSignKeyword_0_0 = (Keyword)cPlusEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMinusEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMinusHyphenMinusKeyword_1_0 = (Keyword)cMinusEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BinOpAdd:
		//	plus='+' |
		//	minus='-';
		public EnumRule getRule() { return rule; }
		
		//plus='+' | minus='-'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//plus='+'
		public EnumLiteralDeclaration getPlusEnumLiteralDeclaration_0() { return cPlusEnumLiteralDeclaration_0; }
		
		//'+'
		public Keyword getPlusPlusSignKeyword_0_0() { return cPlusPlusSignKeyword_0_0; }
		
		//minus='-'
		public EnumLiteralDeclaration getMinusEnumLiteralDeclaration_1() { return cMinusEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getMinusHyphenMinusKeyword_1_0() { return cMinusHyphenMinusKeyword_1_0; }
	}
	public class BinOpMultElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.MyCsv.BinOpMult");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTimesEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTimesAsteriskKeyword_0_0 = (Keyword)cTimesEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDivEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDivSolidusKeyword_1_0 = (Keyword)cDivEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BinOpMult:
		//	times='*' |
		//	div='/';
		public EnumRule getRule() { return rule; }
		
		//times='*' | div='/'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//times='*'
		public EnumLiteralDeclaration getTimesEnumLiteralDeclaration_0() { return cTimesEnumLiteralDeclaration_0; }
		
		//'*'
		public Keyword getTimesAsteriskKeyword_0_0() { return cTimesAsteriskKeyword_0_0; }
		
		//div='/'
		public EnumLiteralDeclaration getDivEnumLiteralDeclaration_1() { return cDivEnumLiteralDeclaration_1; }
		
		//'/'
		public Keyword getDivSolidusKeyword_1_0() { return cDivSolidusKeyword_1_0; }
	}
	
	private final ProgramElements pProgram;
	private final LineIndexElements pLineIndex;
	private final LineIndexCondElements pLineIndexCond;
	private final LineIndexNumElements pLineIndexNum;
	private final FieldIndexElements pFieldIndex;
	private final FieldIndexNameElements pFieldIndexName;
	private final FieldIndexNumElements pFieldIndexNum;
	private final CellIndexElements pCellIndex;
	private final ValueElements pValue;
	private final ValuesElements pValues;
	private final PathElements pPath;
	private final FieldElements pField;
	private final StatementElements pStatement;
	private final LoadElements pLoad;
	private final StoreElements pStore;
	private final ExportJsonElements pExportJson;
	private final ProjectionElements pProjection;
	private final SelectElements pSelect;
	private final DeleteElements pDelete;
	private final DeleteLineElements pDeleteLine;
	private final DeleteFieldElements pDeleteField;
	private final InsertElements pInsert;
	private final InsertLineElements pInsertLine;
	private final InsertFieldElements pInsertField;
	private final ModifyElements pModify;
	private final ModifyLineElements pModifyLine;
	private final ModifyFieldElements pModifyField;
	private final ModifyCellElements pModifyCell;
	private final PrintElements pPrint;
	private final PrintLineElements pPrintLine;
	private final PrintFieldElements pPrintField;
	private final PrintCellElements pPrintCell;
	private final PrintTableElements pPrintTable;
	private final PrintExprElements pPrintExpr;
	private final ExpressionLogElements pExpressionLog;
	private final OrExpressionElements pOrExpression;
	private final AndExpressionElements pAndExpression;
	private final UnaryLogExpressionElements pUnaryLogExpression;
	private final ExpressionLogPrimaryElements pExpressionLogPrimary;
	private final NestedLogExpressionElements pNestedLogExpression;
	private final ExpressionRelElements pExpressionRel;
	private final BinOpRelElements eBinOpRel;
	private final ExpressionCalculElements pExpressionCalcul;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final AdditiveExpressionRhsElements pAdditiveExpressionRhs;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final MultiplicativeExpressionRhsElements pMultiplicativeExpressionRhs;
	private final UnaryExpressionElements pUnaryExpression;
	private final ExpressionCalculPrimaryElements pExpressionCalculPrimary;
	private final AggregatExpressionElements pAggregatExpression;
	private final LitteralIntElements pLitteralInt;
	private final LitteralFloatElements pLitteralFloat;
	private final LitteralStringElements pLitteralString;
	private final NestedExpressionCalculElements pNestedExpressionCalcul;
	private final AggregatElements eAggregat;
	private final BinOpAddElements eBinOpAdd;
	private final BinOpMultElements eBinOpMult;
	private final NbFieldElements pNbField;
	private final FLOATElements pFLOAT;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyCsvGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.pLineIndex = new LineIndexElements();
		this.pLineIndexCond = new LineIndexCondElements();
		this.pLineIndexNum = new LineIndexNumElements();
		this.pFieldIndex = new FieldIndexElements();
		this.pFieldIndexName = new FieldIndexNameElements();
		this.pFieldIndexNum = new FieldIndexNumElements();
		this.pCellIndex = new CellIndexElements();
		this.pValue = new ValueElements();
		this.pValues = new ValuesElements();
		this.pPath = new PathElements();
		this.pField = new FieldElements();
		this.pStatement = new StatementElements();
		this.pLoad = new LoadElements();
		this.pStore = new StoreElements();
		this.pExportJson = new ExportJsonElements();
		this.pProjection = new ProjectionElements();
		this.pSelect = new SelectElements();
		this.pDelete = new DeleteElements();
		this.pDeleteLine = new DeleteLineElements();
		this.pDeleteField = new DeleteFieldElements();
		this.pInsert = new InsertElements();
		this.pInsertLine = new InsertLineElements();
		this.pInsertField = new InsertFieldElements();
		this.pModify = new ModifyElements();
		this.pModifyLine = new ModifyLineElements();
		this.pModifyField = new ModifyFieldElements();
		this.pModifyCell = new ModifyCellElements();
		this.pPrint = new PrintElements();
		this.pPrintLine = new PrintLineElements();
		this.pPrintField = new PrintFieldElements();
		this.pPrintCell = new PrintCellElements();
		this.pPrintTable = new PrintTableElements();
		this.pPrintExpr = new PrintExprElements();
		this.pExpressionLog = new ExpressionLogElements();
		this.pOrExpression = new OrExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pUnaryLogExpression = new UnaryLogExpressionElements();
		this.pExpressionLogPrimary = new ExpressionLogPrimaryElements();
		this.pNestedLogExpression = new NestedLogExpressionElements();
		this.pExpressionRel = new ExpressionRelElements();
		this.eBinOpRel = new BinOpRelElements();
		this.pExpressionCalcul = new ExpressionCalculElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.pAdditiveExpressionRhs = new AdditiveExpressionRhsElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pMultiplicativeExpressionRhs = new MultiplicativeExpressionRhsElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pExpressionCalculPrimary = new ExpressionCalculPrimaryElements();
		this.pAggregatExpression = new AggregatExpressionElements();
		this.pLitteralInt = new LitteralIntElements();
		this.pLitteralFloat = new LitteralFloatElements();
		this.pLitteralString = new LitteralStringElements();
		this.pNestedExpressionCalcul = new NestedExpressionCalculElements();
		this.eAggregat = new AggregatElements();
		this.eBinOpAdd = new BinOpAddElements();
		this.eBinOpMult = new BinOpMultElements();
		this.pNbField = new NbFieldElements();
		this.pFLOAT = new FLOATElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.MyCsv".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// Program
	//Program:
	//	stmts+=Statement+;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//// Useful indexes in CSV world
	//LineIndex:
	//	LineIndexCond | LineIndexNum;
	public LineIndexElements getLineIndexAccess() {
		return pLineIndex;
	}
	
	public ParserRule getLineIndexRule() {
		return getLineIndexAccess().getRule();
	}
	
	//LineIndexCond:
	//	cond=ExpressionLog;
	public LineIndexCondElements getLineIndexCondAccess() {
		return pLineIndexCond;
	}
	
	public ParserRule getLineIndexCondRule() {
		return getLineIndexCondAccess().getRule();
	}
	
	//LineIndexNum:
	//	lines+=INT+;
	public LineIndexNumElements getLineIndexNumAccess() {
		return pLineIndexNum;
	}
	
	public ParserRule getLineIndexNumRule() {
		return getLineIndexNumAccess().getRule();
	}
	
	//FieldIndex:
	//	FieldIndexName | FieldIndexNum;
	public FieldIndexElements getFieldIndexAccess() {
		return pFieldIndex;
	}
	
	public ParserRule getFieldIndexRule() {
		return getFieldIndexAccess().getRule();
	}
	
	//FieldIndexName:
	//	fields+=Field+;
	public FieldIndexNameElements getFieldIndexNameAccess() {
		return pFieldIndexName;
	}
	
	public ParserRule getFieldIndexNameRule() {
		return getFieldIndexNameAccess().getRule();
	}
	
	//FieldIndexNum:
	//	columns+=INT+;
	public FieldIndexNumElements getFieldIndexNumAccess() {
		return pFieldIndexNum;
	}
	
	public ParserRule getFieldIndexNumRule() {
		return getFieldIndexNumAccess().getRule();
	}
	
	//CellIndex:
	//	'(' line=INT ',' (colnum=INT | colname=Field) ')';
	public CellIndexElements getCellIndexAccess() {
		return pCellIndex;
	}
	
	public ParserRule getCellIndexRule() {
		return getCellIndexAccess().getRule();
	}
	
	//// Common arguments
	//Value:
	//	ExpressionCalcul | LitteralString;
	public ValueElements getValueAccess() {
		return pValue;
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}
	
	//Values:
	//	'['? values+=Value (';' values+=Value)* ']'?;
	public ValuesElements getValuesAccess() {
		return pValues;
	}
	
	public ParserRule getValuesRule() {
		return getValuesAccess().getRule();
	}
	
	//Path:
	//	value=STRING;
	public PathElements getPathAccess() {
		return pPath;
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}
	
	//Field:
	//	value=ID
	//	// /!\ We don't accept numbers as Field names.
	//;
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}
	
	//// Statements and primitives
	//Statement:
	//	Load
	//	| Store
	//	| ExportJson
	//	| Projection
	//	| Select
	//	| Delete
	//	| Insert
	//	| Modify
	//	| Print;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//Load:
	//	'Load' path=Path (sepDefined?='sep' '=' sep=STRING)? noHeader?='noheader'?;
	public LoadElements getLoadAccess() {
		return pLoad;
	}
	
	public ParserRule getLoadRule() {
		return getLoadAccess().getRule();
	}
	
	//Store:
	//	'Store' path=Path (sepDefined?='sep' '=' sep=STRING)?;
	public StoreElements getStoreAccess() {
		return pStore;
	}
	
	public ParserRule getStoreRule() {
		return getStoreAccess().getRule();
	}
	
	//ExportJson:
	//	'ExportJson' path=Path;
	public ExportJsonElements getExportJsonAccess() {
		return pExportJson;
	}
	
	public ParserRule getExportJsonRule() {
		return getExportJsonAccess().getRule();
	}
	
	//Projection:
	//	'Projection' field=FieldIndex;
	public ProjectionElements getProjectionAccess() {
		return pProjection;
	}
	
	public ParserRule getProjectionRule() {
		return getProjectionAccess().getRule();
	}
	
	//Select:
	//	'Select' line=LineIndex;
	public SelectElements getSelectAccess() {
		return pSelect;
	}
	
	public ParserRule getSelectRule() {
		return getSelectAccess().getRule();
	}
	
	//Delete:
	//	'Delete' (DeleteLine | DeleteField);
	public DeleteElements getDeleteAccess() {
		return pDelete;
	}
	
	public ParserRule getDeleteRule() {
		return getDeleteAccess().getRule();
	}
	
	//DeleteLine:
	//	'line' lines=LineIndex;
	public DeleteLineElements getDeleteLineAccess() {
		return pDeleteLine;
	}
	
	public ParserRule getDeleteLineRule() {
		return getDeleteLineAccess().getRule();
	}
	
	//DeleteField:
	//	'field' fields=FieldIndex;
	public DeleteFieldElements getDeleteFieldAccess() {
		return pDeleteField;
	}
	
	public ParserRule getDeleteFieldRule() {
		return getDeleteFieldAccess().getRule();
	}
	
	//Insert:
	//	'Insert' (InsertLine | InsertField);
	public InsertElements getInsertAccess() {
		return pInsert;
	}
	
	public ParserRule getInsertRule() {
		return getInsertAccess().getRule();
	}
	
	//InsertLine:
	//	'line' values=Values;
	public InsertLineElements getInsertLineAccess() {
		return pInsertLine;
	}
	
	public ParserRule getInsertLineRule() {
		return getInsertLineAccess().getRule();
	}
	
	//InsertField:
	//	'field' fieldname=Field ':' values=Values;
	public InsertFieldElements getInsertFieldAccess() {
		return pInsertField;
	}
	
	public ParserRule getInsertFieldRule() {
		return getInsertFieldAccess().getRule();
	}
	
	//Modify:
	//	'Modify' (ModifyLine | ModifyField | ModifyCell);
	public ModifyElements getModifyAccess() {
		return pModify;
	}
	
	public ParserRule getModifyRule() {
		return getModifyAccess().getRule();
	}
	
	//ModifyLine:
	//	'line' lines=LineIndex 'with' values=Values;
	public ModifyLineElements getModifyLineAccess() {
		return pModifyLine;
	}
	
	public ParserRule getModifyLineRule() {
		return getModifyLineAccess().getRule();
	}
	
	//ModifyField:
	//	'field' fields=FieldIndex 'with' values=Values;
	public ModifyFieldElements getModifyFieldAccess() {
		return pModifyField;
	}
	
	public ParserRule getModifyFieldRule() {
		return getModifyFieldAccess().getRule();
	}
	
	//ModifyCell:
	//	'cell' cell=CellIndex 'with' value=Value;
	public ModifyCellElements getModifyCellAccess() {
		return pModifyCell;
	}
	
	public ParserRule getModifyCellRule() {
		return getModifyCellAccess().getRule();
	}
	
	//Print:
	//	'Print' (PrintLine | PrintField | PrintCell | {PrintTable} PrintTable | PrintExpr);
	public PrintElements getPrintAccess() {
		return pPrint;
	}
	
	public ParserRule getPrintRule() {
		return getPrintAccess().getRule();
	}
	
	//PrintLine:
	//	'line' lines=LineIndex;
	public PrintLineElements getPrintLineAccess() {
		return pPrintLine;
	}
	
	public ParserRule getPrintLineRule() {
		return getPrintLineAccess().getRule();
	}
	
	//PrintField:
	//	'field' fields=FieldIndex;
	public PrintFieldElements getPrintFieldAccess() {
		return pPrintField;
	}
	
	public ParserRule getPrintFieldRule() {
		return getPrintFieldAccess().getRule();
	}
	
	//PrintCell:
	//	'cell' cell=CellIndex;
	public PrintCellElements getPrintCellAccess() {
		return pPrintCell;
	}
	
	public ParserRule getPrintCellRule() {
		return getPrintCellAccess().getRule();
	}
	
	//PrintTable:
	//	'table';
	public PrintTableElements getPrintTableAccess() {
		return pPrintTable;
	}
	
	public ParserRule getPrintTableRule() {
		return getPrintTableAccess().getRule();
	}
	
	//PrintExpr:
	//	'expr' exp=Value;
	public PrintExprElements getPrintExprAccess() {
		return pPrintExpr;
	}
	
	public ParserRule getPrintExprRule() {
		return getPrintExprAccess().getRule();
	}
	
	//// Logical expressions
	//ExpressionLog:
	//	expr=OrExpression;
	public ExpressionLogElements getExpressionLogAccess() {
		return pExpressionLog;
	}
	
	public ParserRule getExpressionLogRule() {
		return getExpressionLogAccess().getRule();
	}
	
	//OrExpression:
	//	lhs=AndExpression ('or' rhs+=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//AndExpression:
	//	lhs=UnaryLogExpression ('and' rhs+=UnaryLogExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//UnaryLogExpression:
	//	not?='not'? expr=ExpressionLogPrimary;
	public UnaryLogExpressionElements getUnaryLogExpressionAccess() {
		return pUnaryLogExpression;
	}
	
	public ParserRule getUnaryLogExpressionRule() {
		return getUnaryLogExpressionAccess().getRule();
	}
	
	//ExpressionLogPrimary:
	//	ExpressionRel | NestedLogExpression;
	public ExpressionLogPrimaryElements getExpressionLogPrimaryAccess() {
		return pExpressionLogPrimary;
	}
	
	public ParserRule getExpressionLogPrimaryRule() {
		return getExpressionLogPrimaryAccess().getRule();
	}
	
	//NestedLogExpression:
	//	'(' expr=ExpressionLog ')';
	public NestedLogExpressionElements getNestedLogExpressionAccess() {
		return pNestedLogExpression;
	}
	
	public ParserRule getNestedLogExpressionRule() {
		return getNestedLogExpressionAccess().getRule();
	}
	
	//// Bridge between logical and numerical expressions
	//ExpressionRel:
	//	field=Field op=BinOpRel val=Value;
	public ExpressionRelElements getExpressionRelAccess() {
		return pExpressionRel;
	}
	
	public ParserRule getExpressionRelRule() {
		return getExpressionRelAccess().getRule();
	}
	
	//enum BinOpRel:
	//	gt='>' |
	//	lt='<' |
	//	ge='>=' |
	//	le='<=' |
	//	eq='==' |
	//	neq='!=';
	public BinOpRelElements getBinOpRelAccess() {
		return eBinOpRel;
	}
	
	public EnumRule getBinOpRelRule() {
		return getBinOpRelAccess().getRule();
	}
	
	//// Numerical expressions
	//ExpressionCalcul:
	//	expr=AdditiveExpression;
	public ExpressionCalculElements getExpressionCalculAccess() {
		return pExpressionCalcul;
	}
	
	public ParserRule getExpressionCalculRule() {
		return getExpressionCalculAccess().getRule();
	}
	
	//AdditiveExpression:
	//	lhs=MultiplicativeExpression rhs+=AdditiveExpressionRhs*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}
	
	//AdditiveExpressionRhs:
	//	op=BinOpAdd rhs=MultiplicativeExpression;
	public AdditiveExpressionRhsElements getAdditiveExpressionRhsAccess() {
		return pAdditiveExpressionRhs;
	}
	
	public ParserRule getAdditiveExpressionRhsRule() {
		return getAdditiveExpressionRhsAccess().getRule();
	}
	
	//MultiplicativeExpression:
	//	lhs=UnaryExpression rhs+=MultiplicativeExpressionRhs*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//MultiplicativeExpressionRhs:
	//	op=BinOpMult rhs=UnaryExpression;
	public MultiplicativeExpressionRhsElements getMultiplicativeExpressionRhsAccess() {
		return pMultiplicativeExpressionRhs;
	}
	
	public ParserRule getMultiplicativeExpressionRhsRule() {
		return getMultiplicativeExpressionRhsAccess().getRule();
	}
	
	//UnaryExpression:
	//	op?='-'? expr=ExpressionCalculPrimary;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//ExpressionCalculPrimary:
	//	{NbField} NbField | AggregatExpression | LitteralInt | LitteralFloat | NestedExpressionCalcul;
	public ExpressionCalculPrimaryElements getExpressionCalculPrimaryAccess() {
		return pExpressionCalculPrimary;
	}
	
	public ParserRule getExpressionCalculPrimaryRule() {
		return getExpressionCalculPrimaryAccess().getRule();
	}
	
	//AggregatExpression:
	//	aggregatOp=Aggregat arg=Field;
	public AggregatExpressionElements getAggregatExpressionAccess() {
		return pAggregatExpression;
	}
	
	public ParserRule getAggregatExpressionRule() {
		return getAggregatExpressionAccess().getRule();
	}
	
	//LitteralInt:
	//	val=INT;
	public LitteralIntElements getLitteralIntAccess() {
		return pLitteralInt;
	}
	
	public ParserRule getLitteralIntRule() {
		return getLitteralIntAccess().getRule();
	}
	
	//LitteralFloat:
	//	val=FLOAT;
	public LitteralFloatElements getLitteralFloatAccess() {
		return pLitteralFloat;
	}
	
	public ParserRule getLitteralFloatRule() {
		return getLitteralFloatAccess().getRule();
	}
	
	//LitteralString:
	//	val=STRING;
	public LitteralStringElements getLitteralStringAccess() {
		return pLitteralString;
	}
	
	public ParserRule getLitteralStringRule() {
		return getLitteralStringAccess().getRule();
	}
	
	//NestedExpressionCalcul:
	//	'(' expr=ExpressionCalcul ')';
	public NestedExpressionCalculElements getNestedExpressionCalculAccess() {
		return pNestedExpressionCalcul;
	}
	
	public ParserRule getNestedExpressionCalculRule() {
		return getNestedExpressionCalculAccess().getRule();
	}
	
	//enum Aggregat:
	//	count='Count' |
	//	sum='Sum' |
	//	product='Product' |
	//	mean='Mean';
	public AggregatElements getAggregatAccess() {
		return eAggregat;
	}
	
	public EnumRule getAggregatRule() {
		return getAggregatAccess().getRule();
	}
	
	//enum BinOpAdd:
	//	plus='+' |
	//	minus='-';
	public BinOpAddElements getBinOpAddAccess() {
		return eBinOpAdd;
	}
	
	public EnumRule getBinOpAddRule() {
		return getBinOpAddAccess().getRule();
	}
	
	//enum BinOpMult:
	//	times='*' |
	//	div='/';
	public BinOpMultElements getBinOpMultAccess() {
		return eBinOpMult;
	}
	
	public EnumRule getBinOpMultRule() {
		return getBinOpMultAccess().getRule();
	}
	
	//NbField:
	//	'NbField';
	public NbFieldElements getNbFieldAccess() {
		return pNbField;
	}
	
	public ParserRule getNbFieldRule() {
		return getNbFieldAccess().getRule();
	}
	
	//FLOAT ecore::EFloat:
	//	INT '.' INT;
	public FLOATElements getFLOATAccess() {
		return pFLOAT;
	}
	
	public ParserRule getFLOATRule() {
		return getFLOATAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

/*
 * generated by Xtext 2.23.0
 */
package org.xtext.tests

import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.myCsv.Program
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.common.util.URI
import org.xtext.MyCsvStandaloneSetupGenerated
import org.xtext.generator.MyCsvCompilerPython
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.charset.StandardCharsets
import java.io.File
import java.io.BufferedReader
import java.io.InputStreamReader
import org.xtext.generator.MyCsvCompilerBash
import org.xtext.generator.MyCsvInterpreter
import java.io.PrintStream
import org.xtext.generator.Csv
import org.json.simple.parser.JSONParser
import java.io.FileReader
import java.util.ArrayList
import static java.nio.file.StandardCopyOption.*;
import java.nio.file.StandardOpenOption

@ExtendWith(InjectionExtension)
@InjectWith(MyCsvInjectorProvider)
class MyCsvBenchmarkTest {
	
	//create directories for the outputs, if they don't already exist
	def prepareDirectories()
	{
		val ArrayList<String> listFiles =  new ArrayList<String>()
		
		listFiles.add("examples-gen")
		listFiles.add("examples-gen/interpreter")
		listFiles.add("examples-gen/python")
		listFiles.add("examples-gen/bash")
		listFiles.add("examples-gen/stdout")
		listFiles.add("examples-gen/benchmarks")
		
		for(String s : listFiles)
		{
			val f = new File(s)
			if (!f.exists){
			Files.createDirectory(Paths.get(s))
			}
		}
		
	}
	
	def prepareBenchmark(String benchmarksRunCsvPath,String benchmarksMeanCsvPath)
	{
		var f = new File(benchmarksRunCsvPath)
		if (!f.exists){
			Files.createFile(Paths.get(benchmarksRunCsvPath))
		}
		
		f = new File(benchmarksMeanCsvPath)
		if (!f.exists){
			Files.createFile(Paths.get(benchmarksMeanCsvPath))
		}
	}
	
	@Test
	def void compileTests() {
		val nbRuns=20
		val File directoryPath = new File("examples/tests/")
		
		prepareDirectories()
		
		println("----------TESTS----------")
		
		val pythonCompiler = new MyCsvCompilerPython
		val bashCompiler = new MyCsvCompilerBash
		val interpreter = new MyCsvInterpreter
		// Buffer
		var String line;
		var runId=0
		
		// Runtime settings
		val PrintStream mainOut = System.out
		val String mainPath = System.getProperty("user.dir")
		val String interpreterPath = new File("examples-gen/interpreter").absolutePath
		
		//benchmarks
		val csvFilePath="examples/csvFiles/"
		val csvFileNoHeaderPath=csvFilePath+"noheader/"
		val csvFileWithHeaderPath=csvFilePath+"withHeader/"
		val benchmarksRunCsvPath="examples-gen/benchmarks/benchmarksRuns.csv"
		
		val benchmarksMeanCsvPath="examples-gen/benchmarks/benchmarksMean.csv"
		prepareBenchmark(benchmarksRunCsvPath,benchmarksMeanCsvPath)
		
		val headerMean="inputSize,testName,timePython_ns,timePython_ms,timeBash_ns,timeBash_ms,timeInterpreter_ns,timeInterpreter_ms\n"
		val headerRuns="runId,inputSize,testName,timePython_ns,timePython_ms,timeBash_ns,timeBash_ms,timeInterpreter_ns,timeInterpreter_ms\n"
		
		Files.writeString(Paths.get(benchmarksRunCsvPath), headerRuns, StandardCharsets.UTF_8)
		Files.writeString(Paths.get(benchmarksMeanCsvPath), headerMean, StandardCharsets.UTF_8)
		
		
		for (var int sizeEntry=1; sizeEntry<=16; sizeEntry++)
		{
			val inputSize=sizeEntry*100
			val nameInput="withheader"+sizeEntry+".csv"
			val nameNoHeader="noheader"+sizeEntry+".csv"
			Files.copy(Paths.get(csvFileWithHeaderPath+nameInput), Paths.get("examples-gen/input.csv"), REPLACE_EXISTING)
			Files.copy(Paths.get(csvFileNoHeaderPath+nameNoHeader), Paths.get("examples-gen/noheader.csv"), REPLACE_EXISTING)
				
			for (testFile : directoryPath.list())
			{
				var benchmarksMean = new StringBuilder() 
				var benchmarksRun = new StringBuilder()
				
				val basename= testFile.substring(0, testFile.indexOf("."))
				val outputBasename = "output"+basename.substring("test".length, basename.length())
				benchmarksMean.append(inputSize+","+basename+",")
				try {
					// PREPARING testfile
					println("TESTING "+ basename +"...")
					
					val inputMyCsv= "examples/tests/"+basename+".mycsv"
					val compiledPyPath= "examples-gen/python/"+basename+".py"
					val compiledShPath= "examples-gen/bash/"+basename+".sh"
					val stdoutPyPath= "examples-gen/stdout/"+basename+"-Py.stdout.txt"
					val stdoutShPath= "examples-gen/stdout/"+basename+"-Sh.stdout.txt"
					val stdoutInterpreterPath= "examples-gen/stdout/"+basename+"-Interpreter.stdout.txt"
					val outputPyPath= "examples-gen/python/"+outputBasename+".csv"
					val outputShPath= "examples-gen/bash/"+outputBasename+".csv"
					val outputInterpreterPath= "examples-gen/interpreter/"+outputBasename+".csv"
					val outputJsonPyPath= "examples-gen/python/"+outputBasename+".json"
					val outputJsonShPath= "examples-gen/bash/"+outputBasename+".json"
					val outputJsonInterpreterPath= "examples-gen/interpreter/"+outputBasename+".json"
					
					// GETTING MYCSV AST
					val prog = loadMyCSV(URI.createURI(inputMyCsv))
					Assertions.assertNotNull(prog)
					val errors = prog.eResource.errors
					Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
					
					// COMPILING AND WRITING RESULTS
					val compiledPy = pythonCompiler.compile(prog)
					val compiledSh = bashCompiler.compile(prog)
					Files.writeString(Paths.get(compiledPyPath), compiledPy, StandardCharsets.UTF_8);
		    		Files.writeString(Paths.get(compiledShPath), compiledSh, StandardCharsets.UTF_8);
					
					// PREPARE EXECUTION
					val Runtime rt = Runtime.getRuntime();
					val String cmdExecPy = "python3 "+basename+".py"
					val String cmdExecSh = "./"+basename+".sh"
					val File bashFile = new File(compiledShPath)
					bashFile.setExecutable(true);
					println("Execution time ("+inputSize+" lines):")
							
					
					val pyTimes=new ArrayList<Long>()
					val shTimes=new ArrayList<Long>()
					val interpTimes=new ArrayList<Long>()
					
					//benchmark python
					for (var i=0; i<nbRuns; i++)
					{
						val tstart_python = System.nanoTime()
						val Process prPy = rt.exec(cmdExecPy, null, new File("examples-gen/python"));
						prPy.waitFor
						val tend_python = System.nanoTime()
						pyTimes.add(tend_python-tstart_python)
					}
					val pyTime=mean(pyTimes)
					println("\tpython: "+pyTime+" ns ("+pyTime/1000000+" ms)")
					benchmarksMean.append(pyTime+","+(pyTime/1000000)+",")
					
					// EXECUTE PYTHON
					val Process prPy = rt.exec(cmdExecPy, null, new File("examples-gen/python"));
					val pyTerm=prPy.waitFor
					val BufferedReader bfrPy = new BufferedReader(new InputStreamReader(prPy.getInputStream()));
					var stdoutPy = new StringBuilder
					while ((line = bfrPy.readLine()) !== null)
					{
						stdoutPy.append(line + "\n");
					}
					Files.writeString(Paths.get(stdoutPyPath), stdoutPy.toString, StandardCharsets.UTF_8);
					
					for(var i=0; i<nbRuns; i++)
					{
						val tstart_bash = System.nanoTime()
						val Process prSh = rt.exec(cmdExecSh, null, new File("examples-gen/bash"));
						prSh.waitFor
						val tend_bash = System.nanoTime()
						shTimes.add(tend_bash-tstart_bash)
					}
					val shTime=mean(shTimes)
					println("\tbash: "+shTime+" ns ("+shTime/1000000+" ms)")
					benchmarksMean.append(shTime+","+(shTime/1000000)+",")
					
					// EXECUTE BASH
					val Process prSh = rt.exec(cmdExecSh, null, new File("examples-gen/bash"));
					val shTerm=prSh.waitFor
					val BufferedReader bfrSh = new BufferedReader(new InputStreamReader(prSh.getInputStream()));
					var stdoutSh = new StringBuilder
					while ((line = bfrSh.readLine()) !== null)
					{
						stdoutSh.append(line + "\n");
					}
					Files.writeString(Paths.get(stdoutShPath), stdoutSh.toString, StandardCharsets.UTF_8);
					
					// EXECUTE INTERPRETER
					
					// changing context
					System.setProperty("user.dir", interpreterPath)
					val outStream = new PrintStream(stdoutInterpreterPath)
					System.setOut(outStream)
					
					// execution
					var int interpReturnCode = 0
					var long tstart_interp=0
					var long tend_interp=0
					for(var i=0; i<nbRuns; i++)
					{
						try {
							
							tstart_interp = System.nanoTime()
							interpreter.interpretProgram(prog)
							tend_interp = System.nanoTime()
							outStream.flush()
						} catch (Exception e){
							interpReturnCode = 1
							e.printStackTrace
						}
					interpTimes.add(tend_interp-tstart_interp)
					}
					
					// restoring context
					System.setOut(mainOut)
					System.setProperty("user.dir", mainPath)
					
					val interpTime=mean(interpTimes)
					println("\tinterpreter: "+interpTime+" ns ("+interpTime/1000000+" ms)")
					benchmarksMean.append(interpTime+","+(interpTime/1000000)+"\n")
					
					for(var i=0; i<nbRuns;i++)
					{
						runId+=1
						benchmarksRun.append(runId+","+inputSize+","+basename+","+pyTimes.get(i)+","+(pyTimes.get(i)/1000000)+","+shTimes.get(i)+","+(shTimes.get(i)/1000000)+","+interpTimes.get(i)+","+(interpTimes.get(i)/1000000)+"\n")
					}
					
					Files.writeString(Paths.get(benchmarksRunCsvPath), benchmarksRun, StandardCharsets.UTF_8, StandardOpenOption.APPEND)
					Files.writeString(Paths.get(benchmarksMeanCsvPath), benchmarksMean, StandardCharsets.UTF_8, StandardOpenOption.APPEND)	
					
					// ASSERTIONS
					// Executions should fail together
					
					Assertions.assertEquals(interpReturnCode == 0, pyTerm == 0) 
					Assertions.assertEquals(interpReturnCode == 0, shTerm == 0)
					
					// Output should be the same
					val csvInterpreter = new Csv(outputInterpreterPath, ";", false)
					Assertions.assertEquals(csvInterpreter, new Csv(outputPyPath, ";", false))
					Assertions.assertEquals(csvInterpreter, new Csv(outputShPath, ";", false))
					// FIXME: hardcoding the separator isn't robust.
					
					// Compare Json output
					Assertions.assertTrue(compareJson(outputJsonInterpreterPath, outputJsonPyPath))
					Assertions.assertTrue(compareJson(outputJsonInterpreterPath, outputJsonShPath))
					
					// Remark: stdout comparison is done manually because MyCsv doesn't specify the exact way to print.
					
					// DONE
					println("DONE\n")
				
				} catch (Exception e) {
					System.out.println("ERROR: test of " + basename + " aborted:\n"+e+"\n");
					e.printStackTrace
					Assertions.fail("Exception occured.")
				}
			}
		}

	}
	
	def mean(ArrayList<Long> l)
	{
		var long sum=0
		var long len=0
		for(i : l)
		{
			sum+=i
			len+=1
		}
		return (sum/len)
	}
	
	def compareCsv(String outPath1, String outPath2) {
		if(!new File(outPath1).exists && !new File(outPath2).exists){
			return true
		}
		if(!new File(outPath1).exists || !new File(outPath2).exists){
			return false
		}
		return new Csv(outPath1).equals(new Csv(outPath2))
	}
	
	def compareJson(String outPath1, String outPath2) {
		if(!new File(outPath1).exists && !new File(outPath2).exists){
			return true
		}
		if(!new File(outPath1).exists || !new File(outPath2).exists){
			return false
		}
		val JSONParser jParser = new JSONParser
		val json1 = jParser.parse(new FileReader(outPath1));
		val json2 = jParser.parse(new FileReader(outPath2));
				
		return json1.equals(json2)
	}
		
	def loadMyCSV(URI uri){
		new MyCsvStandaloneSetupGenerated().createInjectorAndDoEMFRegistration()
		var res= new ResourceSetImpl().getResource(uri, true);
		res.contents.get(0) as Program
	}
}

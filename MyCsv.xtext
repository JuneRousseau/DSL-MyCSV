grammar org.xtext.MyCsv with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate myCsv "http://www.xtext.org/MyCsv"

Programm:
	stmts+=Statement+
;

FLOAT returns ecore::EFloat:
	INT '.' INT
;

LineIndex:
	(cond=ExpressionBool | lines+=INT+)	
;
FieldIndex:
	(fields+=Field+ | columns+=INT+)
;
CellIndex:
	'(' line=INT ',' (colnum=INT | colname=Field) ')'
;

Statement:
	  Load Path (sep?=STRING)?
	| Store Path (sep?=STRING)?
	| ExportJson Path
	| Project field=FieldIndex
	| Select LineIndex
	| Delete
	| Insert
	| Modify
	| Print
;

Load:
	'Load'
;
Store:
	'Store'
;
ExportJson:
	'ExportJson'
;
Project:
	'Projection'
;
Select:
	'Select'
;

Delete:
	'Delete' ('line' lines=LineIndex | 'field' fields+=FieldIndex)
;

//Les valeurs sont-elles des Const ? Ou des expressions calculable?
Insert:
	'Insert' ('line' values+=Const+ |'field' fieldname=Field values+=Const+)
;
Modify:
	'Modify' ('line' lines=LineIndex 'with' values+=Const+  |
			  'field' field=FieldIndex 'with' values+=Const+  |
			  'cell' cell=CellIndex 'with' value=Const)
;
Print:
	{Print} 'Print' (
		'line' lines=LineIndex |
		'field' field=FieldIndex |
		'cell' cell=CellIndex |
		'table' |
		'expr' exp=ExpressionCalcul
		)
;


NbField:
	'NbField'
;

Path:
	value=STRING //Est-ce qu'on garde le 'path' '=' ??
;


Field:
	value=ID
;

ExpressionBool:
	'not' expr=ExpressionBool
	| lhs=ExpressionRel (BinOpLogique rhs+=ExpressionRel)*
	| '(' ExpressionBool ')'
;

BinOpLogique:
	'and' | 'or' 
;

ExpressionRel:
	field=Field BinOpRel val=Const
;

BinOpRel:
	'>' | '<' | '>=' | '<=' | '==' | '!='
;

Const:
	str=STRING | ent=INT | real=FLOAT
;


ExpressionCalcul:
	AdditiveExpression
;

AdditiveExpression:
	lhs=MultiplicativeExpression (BinOpAdd rhs+=MultiplicativeExpression)*
;

MultiplicativeExpression:
	lhs=UnaryExpression (BinOpMult rhs+=UnaryExpression)*
;

UnaryExpression:
	('-')? expr=ExpressionCalculPrimary
	;
	
ExpressionCalculPrimary:
	{ExpressionCalcul} NbField
	| Aggregat arg=Field
	| val= LitteralInt
	| val= LitteralFloat
	| '(' expr=ExpressionCalcul ')'
;
LitteralInt:
	val=INT
;
LitteralFloat:
	val=FLOAT
;

Aggregat:
	'Count' | 'Sum' | 'Product' | 'Mean'
;

BinOpAdd:
	'+' | '-'
;
BinOpMult:
	'*' | '/'
;
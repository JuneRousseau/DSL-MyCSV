grammar org.xtext.MyCsv with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate myCsv "http://www.xtext.org/MyCsv"

// Programm
Programm:
	stmts+=Statement+
;

// Useful indexes in CSV world
LineIndex:
	(cond=ExpressionLog | lines+=INT+)
;
FieldIndex:
	(fields+=Field+ | columns+=INT+)
;
CellIndex:
	'(' line=INT ',' (colnum=INT | colname=Field) ')'
;

// Common arguments
Value:
	expr=ExpressionCalcul |
	str=STRING
;
Values:
	('[')? first=Value (';' next+=Value)* (']')?
;
Path:
	value=STRING
;
Field:
	value=ID
;

// Statements and primitives
Statement:
	  Load path=Path ('sep' '=' sep?=STRING)?
	| Store path=Path ('sep' '=' sep?=STRING)?
	| ExportJson path=Path
	| Project field=FieldIndex
	| Select line=LineIndex
	| Delete
	| Insert
	| Modify
	| Print
;

Load:
	'Load'
;
Store:
	'Store'
;
ExportJson:
	'ExportJson'
;
Project:
	'Projection'
;
Select:
	'Select'
;

Delete:
	'Delete' ('line' lines=LineIndex | 'field' fields+=FieldIndex)
;
Insert:
	'Insert' ('line' values=Values | 'field' fieldname=Field ':' values=Values)
;
Modify:
	'Modify' ('line' lines=LineIndex 'with' values=Values  |
			  'field' field=FieldIndex 'with' values=Values  |
			  'cell' cell=CellIndex 'with' value=Value)
;
Print:
	{Print}
	'Print' (
		'line' lines=LineIndex |
		'field' field=FieldIndex |
		'cell' cell=CellIndex |
		'table' |
		'expr' exp=Value
		)
;

// Logical expressions
ExpressionLog:
	OrExpression
;
OrExpression:
	lhs=AndExpression ('or' rhs+=AndExpression)*
;
AndExpression:
	lhs=UnaryLogExpression ('and' rhs+=UnaryLogExpression)*
;
UnaryLogExpression:
	('not')? expr=ExpressionLogPrimary
;
ExpressionLogPrimary:
	  	exprRel=ExpressionRel
	  | '(' expr=ExpressionLog ')'
;

// Bridge between logical and numerical expressions
ExpressionRel:
	field=Field BinOpRel val=Value
;
BinOpRel:
	'>' | '<' | '>=' | '<=' | '==' | '!='
;

// Numerical expressions
ExpressionCalcul:
	AdditiveExpression
;
AdditiveExpression:
	lhs=MultiplicativeExpression (BinOpAdd rhs+=MultiplicativeExpression)*
;
MultiplicativeExpression:
	lhs=UnaryExpression (BinOpMult rhs+=UnaryExpression)*
;
UnaryExpression:
	('-')? expr=ExpressionCalculPrimary
;
ExpressionCalculPrimary:
	{ExpressionCalcul} NbField
	| Aggregat arg=Field
	| val= LitteralInt
	| val= LitteralFloat
	| '(' expr=ExpressionCalcul ')'
;

Aggregat:
	'Count' | 'Sum' | 'Product' | 'Mean'
;
BinOpAdd:
	'+' | '-'
;
BinOpMult:
	'*' | '/'
;

LitteralInt:
	val=INT
;
LitteralFloat:
	val=FLOAT
;
NbField:
	'NbField'
;

FLOAT returns ecore::EFloat:
	INT '.' INT
;

grammar org.xtext.MyCsv with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate myCsv "http://www.xtext.org/MyCsv"

Programm:
	stmts+=Statement+
;

FLOAT returns ecore::EFloat:
	INT '.' INT
;

LineIndex:
	(cond=Expression | lines+=INT+) //Conflit entre le INT de lines et le INT reconnu par expression
;									//Ajouter un mot cl√© si on veut une expression ? 'where' ??
FieldIndex:
	(fields+=Field+ | columns+=INT+)
;
CellIndex:
	'(' line=INT ',' (colnum=INT | colname=Field) ')'
;

Statement:
	  Load Path (sep?=STRING)?
	| Store Path (sep?=STRING)?
	| ExportJson Path
	| Project field=FieldIndex
	| Select LineIndex
	| Delete
	| Insert
	| Modify
	| Print
;

Load:
	'Load'
;
Store:
	'Store'
;
ExportJson:
	'ExportJson'
;
Project:
	'Projection'
;
Select:
	'Select'
;

Delete:
	'Delete' ('line' lines=LineIndex | 'field' fields+=FieldIndex)
;
Insert:
	'Insert' ('line' values+=Const+ |'field' fieldname=Field values+=Const+)
;
Modify:
	'Modify' ('line' lines=LineIndex 'with' values+=Const+  |
			  'field' field=FieldIndex 'with' values+=Const+  |
			  'cell' cell=CellIndex 'with' value=Const)
;
Print:
	{Print} 'Print' (
		'line' lines=LineIndex |
		'field' field=FieldIndex |
		'cell' cell=CellIndex |
		'table' |
		'expr' exp=Expression
		)
;


NbField:
	'NbField'
;

Path:
	'path' '=' value=STRING
;

Const:
	str=STRING //| num=INT | real=FLOAT
;

Field:
	value=ID
;

Expression:
	LitteralString
	| Aggregat arg=Field
	| {Expression} NbField
	| '(' Expression ')'
	//LitteralInt
	//| LitteralFloat
;




LitteralString:
	val=STRING
;
LitteralInt:
	val=INT
;
LitteralFloat:
	val=FLOAT
;

Aggregat:
	'Count' | 'Sum' | 'Product' | 'Mean'


/*
BoolExpression:
	UnaryOpLog arg=BoolExpression end=BoolExpressionEnd
	
;
BoolExpressionEnd :
	BinOpLog rhs=BoolExpression end=BoolExpressionEnd | {BoolExpressionEnd} 'boolExpressionEnd'
;

Expression:
 	  UnaryOpLog arg=Expression
	| '(' lhs=Expression BinOpLog rhs=Expression ')'
	| Aggregat arg=Field
	| Const
	| Path
	| {Expression} NbField
//	| '[' exp=Expression ']' 
;


BinOpAdd:
	'+' | '-'
;
BinOpMult:
	'*' | '/'
;
BinOpRel:
	 '=' | '<' | '<='
;
BinOpLog:
	'and' | 'or'
;
UnaryOpAdd:
	'-'
;
UnaryOpLog:
	'not'
;

*/
;